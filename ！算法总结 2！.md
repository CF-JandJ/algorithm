[toc]

# 二叉树基本知识

## 树的描述

1. 结点的层次（深度）：从上往下数有多少层
2. 结点的高度：从下往上数
3. 结点的度：有几个孩子
4. 树的度：各结点的度的最大值
5. 有序数：逻辑上看，树中结点的各子树从左至右是有次序的
6. 无序数：逻辑上看，树中结点的各子树从左至右是无次序的
7. 树的度和m叉树

![image.png](https://note.youdao.com/yws/res/24867/WEBRESOURCE11f8e4a3f2c1985f2d8d3651a79d6586)

## 二叉树的概念

### 满二叉树

- 定义

一颗高度为`h`，且含有`2^h -1`个节点的二叉树

- 满足条件：

1. 只有最后一层有叶子节点
2. 不存在度为1的节点
3. **按层序从1开始编号，结点i的左孩子为`2i`，右孩子为`2i+1`，父节点为`i/2`（向下取整）**
4. i所在的层次：`log_2 (n+1)`或`log_2 n + 1`

![image.png](https://note.youdao.com/yws/res/24875/WEBRESOURCEea8c9547650fe751e91f46e4ba7214a5)

### 完全二叉树

- 定义

当且仅当其每个结点都与高度为h的满二叉树中编号为1-n的结点一一对应时，称为完全二叉树

- 满足条件

1. 只有最后两层可能有叶子节点
2. 最多只有一个度为1的节点
3. 同上3
4. `i <= n/2`为分支节点，`i > n/2`为叶子节点
5. 如果某个节点只有一个孩子，那么肯定是左孩子

![image.png](https://note.youdao.com/yws/res/24859/WEBRESOURCEe9ad147f23bef60ed08199d59895165c)

### 二叉排序树
 
- 定义

左子树上所有节点的关键字均小于根节点的关键字
右子树上所有节点的关键字均大于根节点的关键字
左子树和右子树又各是一颗二叉排序树

![image.png](https://note.youdao.com/yws/res/24861/WEBRESOURCEdda28aa0c79df788f8c49e72861f9fb3)

### 平衡二叉树

- 定义

树上任一节点的左子树和右子树的深度之差不超过1

![image.png](https://note.youdao.com/yws/res/24866/WEBRESOURCE8bde1738574b473cc2a8ac6d0e5800ab)

- 适用场景

适用于以查为主，很少插入/删除的场景

## 二叉树的存储结构

### 二叉树的顺序存储

![image.png](https://note.youdao.com/yws/res/24863/WEBRESOURCE4e9a6c37cf3bcca8b02f8427e0b713c1)

避免空间浪费，二叉树的顺序存储结构，只适合存储完全二叉树

### 二叉树的链式存储

![image.png](https://note.youdao.com/yws/res/24853/WEBRESOURCEed8f396607b98c1ab9fae2a28b48f2c9)

1. `n`个左右指针，即`2n`个指针，`n-1`个指针指向结点，`n+1`个指针指向`nullptr`，可利用空指针域构造线索二叉树


## 二叉树的遍历

![image.png](https://note.youdao.com/yws/res/24878/WEBRESOURCEda6e8202ae80d57ad96ca17a0a51dfe2)

> 前序遍历：绿色，刚进入函数，还没开始递归的时

> 中序遍历：递归遍历完左子树，准备开始遍历右子树时

> 后序遍历：左右子树都遍历完，离开结点时


1. 先序遍历：根左右

```c
void PreOrder(BiTree T){
    if(T!=NULL){
        visit(T);            //访问根结点
        PreOrder(T->lchild); //递归遍历左子树
        PreOrder(T->rchild); //递归遍历右子树
    }
}
```

2. 中序遍历：左根右

```c
void PreOrder(BiTree T){
    if(T!=NULL){
        PreOrder(T->lchild); //递归遍历左子树
        visit(T);            //访问根结点
        PreOrder(T->rchild); //递归遍历右子树
    }
}
```

3. 后序遍历：左右根

```c
void PreOrder(BiTree T){
    if(T!=NULL){
        PreOrder(T->lchild); //递归遍历左子树
        PreOrder(T->rchild); //递归遍历右子树
        visit(T);            //访问根结点
    }
}
```

### 二叉树的层序遍历

1. 初始化一个辅助队列
2. 根结点入队
3. 若队列非空，则队头结点出队，访问该结点，并将其左右孩子插入队尾
4. 重复3直至队列为空

![image.png](https://note.youdao.com/yws/res/24855/WEBRESOURCE520b51b8e04affc64485134b742d8f32)

## 线索二叉树

![image.png](https://note.youdao.com/yws/res/24852/WEBRESOURCE2f5f1d644eb3c13f364b7cfa2269e9b8)

![image.png](https://note.youdao.com/yws/res/24865/WEBRESOURCEa33668da28c94db659f0b496fd3b7cf0)

![image.png](https://note.youdao.com/yws/res/24860/WEBRESOURCE18c0f1a5330b7bdd73bc83d46f866cdf)


## 红黑树

- 适用场景

适用于频繁插入、删除的场景

红黑树是二叉排序树的优化；二叉排序数-> 左子树结点值 <= 根结点值 <= 右子树结点值

![image.png](https://note.youdao.com/yws/res/24857/WEBRESOURCE2b75a138a86dba6cc982bd3e0dc4c1d7)

# 二叉树算法

## 遍历详解

![image.png](https://note.youdao.com/yws/res/24878/WEBRESOURCEda6e8202ae80d57ad96ca17a0a51dfe2)

> 前序遍历：绿色，刚进入函数，还没开始递归的时

> 中序遍历：递归遍历完左子树，准备开始遍历右子树时

> 后序遍历：左右子树都遍历完，离开结点时

```c
void traverse (TreeNode* root){
    if(root == null) return;
    
    //前序遍历位置
    preorder.add(root->val);
    
    //递归左子树
    traverse(root->left);
    
    //中序遍历位置
    inorder.add(root->val);
    
    //递归右子树
    traverse(root->right);
    
    //后序遍历位置
    postorder.add(root->val);
}
```

所以按照顺序可得

`preorder` : 1 2 3 4 5 6 7
`inorder`  : 3 2 4 1 7 6 5
`postorder`: 3 4 2 7 6 5 1

> 需要明白的点

**1. 在相应结点需要做什么: 判断条件/赋值条件...**
**2. 放在在哪个位置：前序/中序/后序**
**3. 前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据**

## 分解问题详解

> 使用场景

将大问题分解成规模更小，结构相同的子问题，然后通过子问题的答案合并出原问题的答案。

> 前中后序遍历

```c
vector<int> traverse (TreeNode* root){
    vector<int> preres,inres,postres;
    if(root == nullptr) return res;
    
    //前序遍历位置
    preres.push_back(root->val);
    preres.addall(traverse(root->left));
    preres.addall(traverse(root->right));
    
    //中序遍历位置
    inres.addall(traverse(root->left));
    inres.push_back(root->val);
    inres.addall(traverse(root->right));
    
    //后序遍历位置
    postres.addall(traverse(root->left));
    postres.addall(traverse(root->right));
    postres.push_back(root->val);
}
```

> 需要明白的点

**1. 这个递归函数的定义是什么？**
**2. 代入这个函数的定义，这个函数中的代码具体在做什么事？**
**3. 在函数中，要利用该函数当成已知功能的函数去调用**


### 实例

#### 二叉树的最大深度 - 两大思路- 回溯/动态规划

![image.png](https://note.youdao.com/yws/res/24868/WEBRESOURCEa42bd4ce9272de4c508d66bb16060773)

```c
/***** 解法一，回溯算法思路 *****/
class Solution {
public:
    int depth = 0;
    int res = 0;

    int maxDepth(TreeNode* root) {
        traverse(root);
        return res;
    }

    // 遍历二叉树
    void traverse(TreeNode* root) {
        if (root == nullptr) {
            return;
        }

        // 前序遍历位置
        depth++;
        // 遍历的过程中记录最大深度
        res = max(res, depth);
        traverse(root->left);
        traverse(root->right);
        // 后序遍历位置
        depth--;
    }
};
```

> 思路

往左搜索，则深度`+1`，往右搜索，则深度`-1`

-------------------

```c
/***** 解法二，动态规划思路 *****/
class Solution2 {
public:
    // 定义：输入一个节点，返回以该节点为根的二叉树的最大深度
    int maxDepth(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        int leftMax = maxDepth(root->left);
        int rightMax = maxDepth(root->right);
        // 根据左右子树的最大深度推出原二叉树的最大深度
        return 1 + max(leftMax, rightMax);
    }
};
```

> 思路

将一个二叉树，分为左右两个二叉树，求左右两个二叉树深度的最大值，最大深度为该值加一。

上述++分为左右两个二叉树++ -- 又可以分为左右两个二叉树 -- 不断迭代

#### 路径总和

![image.png](https://note.youdao.com/yws/res/24876/WEBRESOURCE67ab250b648fffc4c4e235f7b00aa06b)

```c
class Solution {
public:
/* 解法一、遍历二叉树的思路 */
    int target;
    bool found = false;
    // 记录遍历过程中的路径和
    int curSum = 0;

    bool hasPathSum_2(TreeNode* root, int targetSum) {
        if (root == nullptr) {
            return false;
        }
        this->target = targetSum;
        traverse(root);
        return found;
    }

    // 二叉树遍历函数
    void traverse(TreeNode* root) {
        if (root == nullptr) {
            return;
        }
        // 前序遍历位置
        curSum += root->val;
        if (root->left == nullptr && root->right == nullptr) {
            if (curSum == target) {
                found = true;
            }
        }

        traverse(root->left);
        traverse(root->right);

        // 后序遍历位置
        curSum -= root->val;
    }
}
```

> 注意

不能将
```c
if (root->left == nullptr && root->right == nullptr) {
    if (curSum == target) {
        found = true;
    }
}
```
改为
```c
if(curSum == target) found = true;
//放在中序遍历位置
```
因为递归调用逻辑，调用完左边之后，会返回函数栈，调用右边，再以此返回函数栈，所以每次调用完右边之后，都会进行这个判断，所以这种情况不是叶子节点处

------------------------
```c
class Solution {
public:
    /* 解法二、分解问题的思路 */
    // 定义：输入一个根节点，返回该根节点到叶子节点是否存在一条和为 targetSum 的路径
    bool hasPathSum(TreeNode* root, int targetSum) {
        // base case
        if (root == nullptr) {
            return false;
        }
        if (root->left == nullptr && root->right == nullptr && root->val == targetSum) {
            return true;
        }

        return hasPathSum(root->left, targetSum - root->val)
                || hasPathSum(root->right, targetSum - root->val);
    }
}
```

> 分析

- 写出迭代终止条件

即`root == nullptr`和满足条件`true`的情况。

- 迭代参数如何写？

将一个大情况分为左右两个相同的情况，即计算左右两个二叉树，判断其值是否为总和大小

左右两个二叉树 -- 再次分别分为左右两个二叉树，不断迭代

只要两边一边符合则为`true`，否则为`false`

#### 翻转二叉树

![image.png](https://note.youdao.com/yws/res/24864/WEBRESOURCE9b85047c6fd7799d5c57eb89b3d93f1b)

一样的思路，遍历和分解问题

```c
// 「遍历」的思路
class Solution {
public:
    // 主函数
    TreeNode* invertTree(TreeNode* root) {
        // 遍历二叉树，交换每个节点的子节点
        traverse(root);
        return root;
    }

    // 二叉树遍历函数
    void traverse(TreeNode* root) {
        if (root == nullptr) {
            return;
        }

        /**** 前序位置 ****/
        // 每一个节点需要做的事就是交换它的左右子节点
        TreeNode* tmp = root->left;
        root->left = root->right;
        root->right = tmp;

        // 遍历框架，去遍历左右子树的节点
        traverse(root->left);
        traverse(root->right);
    }
};

```

-------------
```c
// 「分解问题」的思路
class Solution2 {
public:
    // 定义：将以 root 为根的这棵二叉树翻转，返回翻转后的二叉树的根节点
    TreeNode* invertTree(TreeNode* root) {
        if (root == nullptr) {
            return nullptr;
        }
        // 利用函数定义，先翻转左右子树
        TreeNode* left = invertTree(root->left);
        TreeNode* right = invertTree(root->right);

        // 然后交换左右子节点
        root->left = right;
        root->right = left;

        // 和定义逻辑自恰：以 root 为根的这棵二叉树已经被翻转，返回 root
        return root;
    }
};
```

#### `N`叉树的前序遍历

![image.png](https://note.youdao.com/yws/res/24862/WEBRESOURCE9add5c77d09c04fd02cdafe550e86046)

```c
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    vector<int> res;

    void traveres(Node* root){
        if(root == nullptr) return;

        res.push_back(root->val);

        for(auto c:root->children){
            traveres(c);
        }
    }

    vector<int> preorder(Node* root) {
        traveres(root);
        return res;
    }
};
```

> `N`叉树和二叉树的区别就是 一个调用`left` and `right`，一个循环遍历

####  左叶子之和

![image.png](https://note.youdao.com/yws/res/24856/WEBRESOURCEb7df03de48bc675843ef743fa6457a96)


```c
class Solution {
public:
    int sum = 0;

    void traverse(TreeNode* root){
        if(root == nullptr) return;

        if(root->left != nullptr){
            if(root->left->left == nullptr && root->left->right == nullptr){
                sum += root->left->val;
            }
        }
        traverse(root->left);
        traverse(root->right);
    }
    

    int sumOfLeftLeaves(TreeNode* root) {
        traverse(root);
        return sum;
    }
};
```

> 思路

增加一个判断条件，找到其是否为左叶子：倒数第二层的下下层左右都为`nullptr`

> 为什么要从倒数第二层开始？

因为这样才能确保是左叶子，如果是最后一层判断，则为叶子之和

#### 前序遍历

![image.png](https://note.youdao.com/yws/res/24880/WEBRESOURCE554e2f9cb4511faa116ac34e5f235c64)

```c
----------方法1：分解----------
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int>res;
        if(root == nullptr) return res;
        res.push_back(root->val);
        auto preleft  = preorderTraversal(root->left);
        for(auto c:preleft){
            res.push_back(c);
        }
        auto preright = preorderTraversal(root->right);
        for(auto c:preright){
            res.push_back(c);
        }
        return res;
    }
};
```

```c
----------方法2：遍历----------
class Solution {
public:

    vector<int>res;

    void traverse(TreeNode* root){
        if(root == nullptr) return;

        res.push_back(root->val);
        traverse(root->left);
        traverse(root->right);
    }

    vector<int> preorderTraversal(TreeNode* root) {
        traverse(root);
        return res;
    }
};
```

#### 二叉树最小深度

![image.png](https://note.youdao.com/yws/res/24854/WEBRESOURCE0d8408cc89425ff48cf6ccefc505c06d)

> 分析

要注意和二叉树最大深度的区别

```c
class Solution {
public:
    int count =0;
    int res = INT_MAX;

    void traverse(TreeNode* root){
        if(root == nullptr) return;

        count++;
        if(root->left == nullptr && root->right == nullptr){
            res = min(res,count);
        }
        traverse(root->left);
        traverse(root->right);
        count--;
    }

    int minDepth(TreeNode* root) {
        traverse(root);
        return res == INT_MAX ? 0 : res;
    }
};
```

> 注意：

增加判断是否为叶子节点的条件，如果为叶子节点，那么赋值，不是则继续迭代

判断是否为叶子节点的条件：

```c
root->left == nullptr && root->right == nullptr
```

#### 打印长度为`n`的`k`进制数

> 题目

请你实现一个函数，接受一个正整数 `n`，函数能够打印所有长度为 `n` 的二进制数。例如输入n = 3，算法打印000 001 010 011 100 101 110 111，共2^3 = 8个结果

```c
string path;

void generateNumber(int n) {
	if (n == 0) {
		cout << path << " ";
		return;
	}

	for (int i = 0; i < 2; i++) {
		string c = to_string(i);
		path += c;
		generateNumber(n - 1);
		path = path.substr(0,path.size() - 1);
	}
}

int main(){
    generateNumber(2);
}
```

- 结果

![image.png](https://note.youdao.com/yws/res/24871/WEBRESOURCE6f14b149b0616796b0e632e81852c3b6)


> 思路

可以把该问题演化为二叉树的问题

![image.png](https://note.youdao.com/yws/res/24869/WEBRESOURCE3e94e164036645a92fb3e04ee7bfc25d)

找到左节点-赋值，找到右节点-赋值，找完一层到下一层，直至到叶子结点这层打印出结果

> 为什么左遍历，右遍历放在循环里面？

因为如果都放在里面，只会跳过根结点，其他情况一样

> 什么情况为`k`进制？

把循环次数改为`k`即可

```
for (int i = 0; i < 2; i++)
----
for (int i = 0; i < k; i++)
```

#### 路径总和 II

![image.png](https://note.youdao.com/yws/res/24873/WEBRESOURCE73e0f6add95fee292e271e3d864d566e)

```c
class Solution {
public:
    vector<vector<int>> res;
    vector<int> Sf;
    int sum=0;
    int target;
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        target = targetSum;
        traverse(root);
        return res;
    }

    void traverse(TreeNode* root){
        if(root == nullptr) return;

        Sf.push_back(root->val);
        sum += root->val;
        
        if(root->left == nullptr && root->right == nullptr){
            if(sum == target) res.push_back(Sf);
        }
        
        traverse(root->left);
        traverse(root->right);
        
        sum -= root->val;
        Sf.pop_back();
    }
};
```

> 思路

判断总和等于`target`：设置一个`sum`，访问加，退出减
何时插入：当访问到根结点，并且满足条件时


#### 相同的树

![image.png](https://note.youdao.com/yws/res/24881/WEBRESOURCE430808e6a8fcc322f84b3701b4a5a1be)

```c
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        //两个都为空，则相等
        if(p == nullptr && q == nullptr) return true;
        //其中一个为空，一个不为空（因为如果都为空则直接执行上面）
        if(p == nullptr || q == nullptr) return false;
        //此时都不为空
        if(p->val != q->val) return false;
        
        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);
    }
};
```

> 分析

1. 大问题可以分解为多个小问题，可以用分解√
2. 把`isSameTree`当成已知函数去调用
3. 判断什么时候返回`true`，什么时候返回`false`

#### 二叉树展开为链表

<span id = "二叉树展开为链表导航"></span>

![image.png](https://note.youdao.com/yws/res/24874/WEBRESOURCE60b11ecc749302b9bcd72a23ad942d24)

```c
class Solution {
public:
    // 定义：将以 root 为根的树拉平为链表
    void flatten(TreeNode* root) {
        // base case
        if (root == nullptr) return;
        // 先递归拉平左右子树
        flatten(root->left);
        flatten(root->right);

        /****后序遍历位置****/
        // 1、左右子树已经被拉平成一条链表
        TreeNode* left = root->left;
        TreeNode* right = root->right;

        // 2、将左子树作为右子树
        root->left = nullptr;
        root->right = left;

        // 3、将原先的右子树接到当前右子树的末端
        TreeNode* p = root;
        while (p->right != nullptr) {
            p = p->right;
        }
        p->right = right;
    }
};
```

> 分析

1. 可以把这个问题分为：先左子树展开，后右子树展开，将左子树连接上根结点，将右子树连接到左子树的叶子结点，即可
2. 将`flatten`调用展开
3. 当为`root`为空时，`return`

#### 杨辉三角 II

![image.png](https://note.youdao.com/yws/res/24879/WEBRESOURCE90cea52f8a8dc872bcaae8d671b19399)

```c
class Solution {
public:
    // 定义：输入行数，返回该行的杨辉三角数列
    vector<int> getRow(int rowIndex) {
        vector<int> curRow;
        // 每一行开头是 1
        curRow.push_back(1);
        // base case
        if (rowIndex == 0) return curRow;

        // 递归计算出上一行
        vector<int> preRow = getRow(rowIndex - 1);
        for (int i = 0; i < preRow.size() - 1; i++) {
            // 这一行每个元素等于上一行的两个相邻元素之和
            curRow.push_back(preRow[i] + preRow[i + 1]);
        }
        // 每一行结尾是 1
        curRow.push_back(1);
        return curRow;
    }
};
```

#### 另一棵树的子树

<span id = "另一棵树的子树导航"></span>

![image.png](https://note.youdao.com/yws/res/24877/WEBRESOURCE94cea598c274955161896187cacb5854)

```c
class Solution {
public:
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        if(root == nullptr) return subRoot == nullptr;

        if(isSametree(root,subRoot)) return true;

        return isSubtree(root->left,subRoot) || isSubtree(root->right,subRoot);
    }

    bool isSametree(TreeNode* root,TreeNode* otherRoot){
        if(root == nullptr && otherRoot == nullptr) return true;
        if(root == nullptr || otherRoot == nullptr) return false;

        if(root->val != otherRoot->val) return false;

        return isSametree(root->left,otherRoot->left) && isSametree(root->right,otherRoot->right);
    }

};
```

> 分析

1. 发现可以用分解：化为子问题
2. 现在已经知道一个函数，可以判断其子树是否包含相同结构
3. 现在该情况下，判断是否满足：如果两个相同-满足，两个不同-不满足

```
两个相同 `same` - return true;
两个都为 `true` - return true;
两个不同 - 判断其左右子树是否有相同结构
```

4. 化为子问题：有左右两个子树，判断其是否有相同结构

####  二叉树中的链表

![image.png](https://note.youdao.com/yws/res/24858/WEBRESOURCEe0bc4c64853d70e52a98650676c446fd)

```c
class Solution {
public:
    bool isSubPath(ListNode* head, TreeNode* root) {
        if(head == nullptr) return true;
        if(root == nullptr) return false;
        if(isSame(head,root)) return true;
        return isSubPath(head,root->left) || isSubPath(head,root->right);
    }

    bool isSame(ListNode*head,TreeNode* root){
        if(head == nullptr) return true;
        if(root == nullptr) return false;

        if(head->val != root->val) return false;
        return isSame(head->next,root->left) || isSame(head->next,root->right);
    }
};
```

> 分析

1. 可以化为子问题
2. 现在这种情况，什么时候满足，什么时候不满足

>> 当链表到结尾时，表示满足，当根结点到末尾，链表不到末尾，不满足。初始情况，根结点就是，链表头，判断是否相同


#### 二叉树的直径

![image.png](https://note.youdao.com/yws/res/27450/WEBRESOURCE47390fa165527ad97d75b21ac577c82f)

```c
class Solution {
    int maxDiameter = 0;

public:
    int diameterOfBinaryTree(TreeNode* root) {
        maxDepth(root);
        return maxDiameter;
    }

    int maxDepth(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        int leftMax = maxDepth(root->left);
        int rightMax = maxDepth(root->right);
        // 后序遍历位置顺便计算最大直径
        maxDiameter = max(maxDiameter, leftMax + rightMax);
        return 1 + max(leftMax, rightMax);
    }
};
```
 
#### 填充每个节点的下一个右侧节点指针

> 遍历方法

```c
class Solution {
public:
    // 主函数
    Node* connect(Node* root) {
        if (root == nullptr) return nullptr;
        // 遍历「三叉树」，连接相邻节点
        traverse(root->left, root->right);
        return root;
    }

    // 三叉树遍历框架
    void traverse(Node* node1, Node* node2) {
        if (node1 == nullptr || node2 == nullptr) {
            return;
        }
        /**** 前序位置 ****/
        // 将传入的两个节点穿起来
        node1->next = node2;
        
        // 连接相同父节点的两个子节点
        traverse(node1->left, node1->right);
        traverse(node2->left, node2->right);
        // 连接跨越父节点的两个子节点
        traverse(node1->right, node2->left);
    }
};
```


## 总结 DFS(深度优先算法)/递归

二叉树解题的思维模式分两类：

1、是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 `traverse` 函数配合外部变量来实现，这叫「遍历」的思维模式。`（DFS,BFS）`

2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。

无论使用哪种思维模式，你都需要思考：

如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

### 遍历

- 基本模板:

```c
void traverse (TreeNode* root){
    if(root == null) return;
    
    //前序遍历位置
    preorder.add(root->val);
    
    //递归左子树
    traverse(root->left);
    
    //中序遍历位置
    inorder.add(root->val);
    
    //递归右子树
    traverse(root->right);
    
    //后序遍历位置
    postorder.add(root->val);
}
```

- 明白迭代遍历顺序：

![image.png](https://note.youdao.com/yws/res/24870/WEBRESOURCE7aa17a645b8a6321c7ec5b4d5694f89a)

- 遍历位置影响

前序位置的代码执行是自顶向下的，后序位置的代码执行是自底向上的

序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据

**只有后序位置才能通过返回值获取子树的信息，发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了**



- 根据题目条件，分析两个问题：

1. 在相应结点需要做什么: 判断条件/赋值条件...
2. 放在在哪个位置：前序/中序/后序

- 常见判断条件

1. 要到叶子结点处

```c
if(root->left == nullptr && root->right == nullptr);
```

常见：最小深度（求深度，肯定从根结点到叶子结点），路径总和（从头到尾）

2. 不仅到叶子处，还要分左右叶子

```
if(root->left != nullptr){
    if(root->left->left == nullptr && root->left->right == nullptr){ }
}
```

常见：左子叶之和

- 放在哪个位置

1. 求和

```c
num += root.val;

traverse(root->left);
traverse(root->right);

num -= root.val;
```

根据上面调用栈的顺序来判别

### 分解


> 使用场景

将大问题分解成规模更小，结构相同的子问题，然后通过子问题的答案合并出原问题的答案。

> 基本模板

```c
vector<int> traverse (TreeNode* root){
    vector<int> preres,inres,postres;
    if(root == nullptr) return res;
    
    //前序遍历位置
    preres.push_back(root->val);
    preres.addall(traverse(root->left));
    preres.addall(traverse(root->right));
    
    //中序遍历位置
    inres.addall(traverse(root->left));
    inres.push_back(root->val);
    inres.addall(traverse(root->right));
    
    //后序遍历位置
    postres.addall(traverse(root->left));
    postres.addall(traverse(root->right));
    postres.push_back(root->val);
}
```

> 需要明白的点

**1. 这个递归函数的定义是什么？**
**2. 代入这个函数的定义，这个函数中的代码具体在做什么事？**
**3. 在函数中，要利用该函数当成已知功能的函数去调用**
**4. 千万不能跳进递归**
**5. 前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据**

> 拿到一个题目如何判断是否可以用分解

1. 判断原问题是否可以分解为规模更小的子问题（一个部门有多个相同的小部分组成）


> 具体步骤

1. 判断原问题是否可以分解为规模更小的子问题（将子问题代入，是否能组成原问题），可以得出大致步骤
2. 把函数当成已知函数去调用
3. 在当前情况下，判断什么时候满足条件，什么时候不满足条件，其中利用到函数，写出相应步骤和返回值，以及子问题情况下

可参考[to1](#二叉树展开为链表导航),[**to2^**](#另一棵树的子树导航)


## 迭代

- 模拟递归调用栈

```c
class Demo2{
    stack<TreeNode*>stk;
    void traverse(TreeNode* root){
        if(root == nullptr) return ;
        
        //前序遍历位置
        stk.push(root);
        traverse(root->left);
        //中序遍历位置
        traverse(root->right);
        //后序遍历位置
        stk.pop(root);
    }
}
```

1. 前序遍历：遍历左子树的时候
2. 中序遍历：左子树遍历完，且右子树没有遍历的时候
3. 后序遍历：右子树遍历完

```c
class Demo{
    stack<TreeNode*>stk;
    void pushLeftBranch(TreeNode* p){
        while(p != null){
            //前序遍历代码位置
            stk.push(p);
            p = p.left;
        }
    }
    
    void traverse(TreeNode* root){
        TreeNode* visited = new TreeNode(-1);
        pushLeftBranch(root);
        while(!stk.empty()){
            TreeNode* p = stk.top();
            
            if((p.left == null || p.left == visited) && p.right == visited){
                //中序遍历代码位置
                pushLeftBranch(p.right);
            }
            
            if(p.right == null || p.right == visited){
                //后序遍历位置
                
                visited = stk.pop();
            }
        }
    }
}
```

### 层序遍历

> 如何层次遍历?抓住每一层每一层遍历这个特点，从左至右，所以考虑用queue

- 从上至下遍历

```c
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>>res;
        if(root == nullptr) return res;

        queue<TreeNode*> qe;
        qe.push(root);
        while(!qe.empty()){
            int size = qe.size();

            vector<int> peer;
            for(int i=0;i<size;i++){
                TreeNode* cur = qe.front();
                peer.push_back(cur->val);
                qe.pop();
                if(cur->left != nullptr) qe.push(cur->left);
                if(cur->right != nullptr) qe.push(cur->right);
            }
            res.push_back(peer);
        }
        return res;
    }
};
```

> 分析

存储一个队列，该队列记录所有下一层的节点。

遍历当前队列的数量，并判断左右子节点是否存在，存在则加入队列中


- 从下至上遍历

```c
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        list<vector<int>>res;
        if(root == nullptr) return vector<vector<int>>{};

        queue<TreeNode*> qe;
        qe.push(root);
        while(!qe.empty()){
            int size = qe.size();

            vector<int> peer;
            for(int i=0;i<size;i++){
                TreeNode* cur = qe.front();
                peer.push_back(cur->val);
                qe.pop();
                if(cur->left != nullptr) qe.push(cur->left);
                if(cur->right != nullptr) qe.push(cur->right);
            }
            res.push_front(peer);
        }

        vector<vector<int>> e;
        for(auto &c:res){
            e.push_back(c);
        }
        return e;
    }
};
```

> 分析

存储的时候，往前存储，这样从上往下遍历的时候显示出来的就是从下往上遍历的结果

### 实例

#### 二叉树的最小深度

![image.png](https://note.youdao.com/yws/res/24854/WEBRESOURCE0d8408cc89425ff48cf6ccefc505c06d)

```c
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (root == NULL) return 0;
        queue<TreeNode*> q;
        q.push(root);
        // root 本身就是一层，depth 初始化为 1
        int depth = 1;

        while (!q.empty()) {
            /* 层数 step */
            int sz = q.size();
            /* 将当前队列中的所有节点向四周扩散 */
            for (int i = 0; i < sz; i++) {
                TreeNode* cur = q.front();
                q.pop();
                /* 判断是否到达终点 */
                if (cur->left == NULL && cur->right == NULL)
                    return depth;
                /* 将 cur 的相邻节点加入队列 */
                if (cur->left != NULL)
                    q.push(cur->left);
                if (cur->right != NULL)
                    q.push(cur->right);
            }
            /* 这里增加步数 */
            depth++;
        }
        return depth;
    }
};
```


#### 最大层内元素和

![image.png](https://note.youdao.com/yws/res/24872/WEBRESOURCEca02caab75e235095ab8a9734417ea24)

```c
class Solution {
public:
    int maxLevelSum(TreeNode* root) {
        if (!root) return 0;
        queue<TreeNode*> q;
        q.push(root);
        // 记录 BFS 走到的层数
        int depth = 1;
        // 记录元素和最大的那一行和最大元素和
        int res = 0, maxSum = INT_MIN;

        while (!q.empty()) {
            int sz = q.size();
            int levelSum = 0;
            // 遍历这一层
            for (int i = 0; i < sz; i++) {
                TreeNode* cur = q.front();
                q.pop();
                levelSum += cur->val;

                if (cur->left) q.push(cur->left);
                if (cur->right) q.push(cur->right);
            }
            if (levelSum > maxSum) {
                // 更新最大元素和
                res = depth;
                maxSum = levelSum;
            }
            depth++;
        }
        return res;
    }
};
```

> 分析

按层遍历，用BFS算法进行迭代，存储最大元素和最大位置


#### 岛屿数量（BFS算法扩展应用）

![image.png](https://note.youdao.com/yws/res/24851/WEBRESOURCE76d89a17e6ec1b52b119334d99a66de2)

> BFS算法

```c
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        //BFS
        int count=0;
        for(int i=0;i<grid.size();i++){
            for(int j=0;j<grid[0].size();j++){
                if(grid[i][j] == '1'){
                    bfs(grid,i,j);
                    count++;
                }
            }
        }
        return count;
    }

    void bfs(vector<vector<char>>& grid, int x, int y) {
        queue<vector<int>> q;
        q.push(vector<int>{ x,y });
        grid[x][y] = '0';

        while (!q.empty()) {
            int sz = q.size();
            for(int k = 0;k<sz;k++){
                auto c = q.front();
                int i = c[0],j = c[1];
                q.pop();
        
                if (i + 1 < grid.size() && grid[i+1][j] == '1') {
                    q.push(vector<int>{ i + 1,j + 0 });
                    grid[i+1][j] = '0';
                }
                if (i - 1 >= 0 && grid[i-1][j] == '1') {
                    q.push(vector<int>{ i - 1,j + 0 });
                    grid[i-1][j] = '0';
                }
                if (j + 1 < grid[0].size() && grid[i][j+1] == '1') {
                    q.push(vector<int>{ i + 0,j + 1 });
                    grid[i][j+1] = '0';
                }
                if (j - 1 >= 0 && grid[i][j-1] == '1') {
                    q.push(vector<int>{ i + 0,j - 1 });
                    grid[i][j-1] = '0';
                }
            }   
        }
    }   
};
```

> 分析

遍历每个元素，如果该元素为`1`,则采用`BFS`算法，将其周围相连的岛屿都加入队列，且变为`0`

> 递归算法

```c
class Solution {
    // 主函数，计算岛屿数量
public:
    int numIslands(vector<vector<char>>& grid) {
        int res = 0;
        int m = grid.size(), n = grid[0].size();
        // 遍历 grid
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '1') {
                    // 每发现一个岛屿，岛屿数量加一
                    res++;
                    // 然后使用 DFS 将岛屿淹了
                    dfs(grid, i, j);
                }
            }
        }
        return res;
    }

private:
    // 从 (i, j) 开始，将与之相邻的陆地都变成海水
    void dfs(vector<vector<char>>& grid, int i, int j) {
        int m = grid.size(), n = grid[0].size();
        if (i < 0 || j < 0 || i >= m || j >= n) {
            // 超出索引边界
            return;
        }
        if (grid[i][j] == '0') {
            // 已经是海水了
            return;
        }
        // 将 (i, j) 变成海水
        grid[i][j] = '0';
        // 淹没上下左右的陆地
        dfs(grid, i + 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i - 1, j);
        dfs(grid, i, j - 1);
    }
};
```

## 总结 BFS(广度优先算法)/迭代

1. BFS迭代算法将每层的元素遍历完，逐步往外面扩。
2. 重要的就是创建一个`queue`来存储每层的元素，通过`int sz = queue.size()`来保存当前层的个数，并且将符合条件的插入`queue`中，作为下一层迭代

- 模板

```c
class Demo{
    stack<TreeNode*>stk;
    void pushLeftBranch(TreeNode* p){
        while(p != null){
            //前序遍历代码位置
            stk.push(p);
            p = p.left;
        }
    }
    
    void traverse(TreeNode* root){
        TreeNode* visited = new TreeNode(-1);
        pushLeftBranch(root);
        while(!stk.empty()){
            TreeNode* p = stk.top();
            
            if((p.left == null || p.left == visited) && p.right == visited){
                //中序遍历代码位置
                pushLeftBranch(p.right);
            }
            
            if(p.right == null || p.right == visited){
                //后序遍历位置
                
                visited = stk.pop();
            }
        }
    }
}
```

## DFS和BFS

- DFS

空间复杂度：树高

一列一列往右走（如果先遍历左）

不管有多少条岔路，先一条路走到底，不成功就返回上一个路口然后就选择下一条岔路

- BFS

空间复杂度：层结点数

一层一层往下走

在面临一个路口时，把所有的岔路口都记下来，然后选择其中一个进入，然后将它的分路情况记录下来，然后再返回来进入另外一个岔路，并重复这样的操作


# 递归修改数据结构

```c
void printList(ListNode* head){
    ListNode p = head;
    while(p != null){
        cout<< p->val<<" ";
    }
}

------递归

void printList(ListNode* head){
    if(head == null) return;
    
    cout<<head->val<<" ";
    printList(head->next);
}

```

```c
void printArray(vector<int> nums){
    for(int i=0;i<nums.size();i++){
        cout<<nums[i]<<" ";
    }
}

------递归

void printArray(vector<int> nums){
    printArray(nums,0);
}
void printArray(vector<int> nums,int i){
    if(i == num.size()) return ;
    cout<<nums[i]<<" ";
    printArray(nums,i+1);
}
```

```c
ListNode* addLast(ListNode* head,int val){
    if(head == nullptr) return new ListNode(val);
    
    ListNode* p = head;
    while(p->next != null) p =p.next;
    
    p.next = new ListNode(val);
    return head;
}

------递归

ListNode* addLast(ListNode* head,int val){
    if(head == nullptr) return new ListNode(val);
    
    head->next = addLast(head->next,val);
    return head;
}
```

```c
ListNode* removeLast(ListNode* head){
    if(head->next == nullptr) return nullptr;
    ListNode* p = head;
    while(p->next->next != nullptr){
        p=p->next;
    }
    p->next = null;
    return head;
}

------递归

LsitNode* removeLast(ListNode* head){
    if(head->next == nullptr) return nullptr;
    head->next = removeLast(head->next);
    return head;
}
```

## 构造二叉树

二叉树的构造问题一般都是使用「分解问题」的思路：构造整棵树 = 根节点 + 构造左子树 + 构造右子树

### 构造最大二叉树

> 题目

给定一个不重复的整数数组`nums`。 最大二叉树可以用下面的算法从 `nums` 递归地构建:
创建一个根节点，其值为`nums`中的最大值。
递归地在最大值左边的子数组前缀上构建左子树。
递归地在最大值右边的子数组后缀上构建右子树。
返回`nums`构建的最大二叉树 。

```c
class Solution {
public:
    /* 主函数 */
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        return build(nums, 0, nums.size() - 1);
    }

    /* 定义：将 nums[lo..hi] 构造成符合条件的树，返回根节点 */
    TreeNode* build(vector<int>& nums, int lo, int hi) {
        /* base case */
        if (lo > hi) {
            return nullptr;
        }

        /* 找到数组中的最大值和对应的索引 */
        int index = -1, maxVal = INT_MIN;
        for (int i = lo; i <= hi; i++) {
            if (maxVal < nums[i]) {
                index = i;
                maxVal = nums[i];
            }
        }

        TreeNode* root = new TreeNode(maxVal);
        /* 递归调用构造左右子树 */
        root->left = build(nums, lo, index - 1);
        root->right = build(nums, index + 1, hi);

        return root;
    }
};
```


### 从前序与中序遍历序列构造二叉树 

```c
class Solution {
private:
    // 存储 inorder 中值到索引的映射
    unordered_map<int, int> valToIndex;

public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        for (int i = 0; i < inorder.size(); i++) {
            valToIndex[inorder[i]] = i;
        }
        return build(preorder, 0, preorder.size() - 1,
                     inorder, 0, inorder.size() - 1);
    }

    /*
       定义：前序遍历数组为 preorder[preStart..preEnd]，
       中序遍历数组为 inorder[inStart..inEnd]，
       构造这个二叉树并返回该二叉树的根节点
    */
    TreeNode* build(vector<int>& preorder, int preStart, int preEnd,
                    vector<int>& inorder, int inStart, int inEnd) {
        if (preStart > preEnd) {
            return nullptr;
        }

        // root 节点对应的值就是前序遍历数组的第一个元素
        int rootVal = preorder[preStart];
        // rootVal 在中序遍历数组中的索引
        int index = valToIndex[rootVal];

        int leftSize = index - inStart;

        // 先构造出当前根节点
        TreeNode* root = new TreeNode(rootVal);
        // 递归构造左右子树
        root->left = build(preorder, preStart + 1, preStart + leftSize,
                           inorder, inStart, index - 1);
        root->right = build(preorder, preStart + leftSize + 1, preEnd,
                            inorder, index + 1, inEnd);

        return root;
    }
};
```

> 分析

![](https://labuladong.github.io/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%972/1.jpeg)

根据中序遍历，找到`root`左子树元素个数和`root`右子树元素个数，从而得到`root`左右子树对应的结点

![](https://labuladong.github.io/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%972/2.jpeg)

![](https://labuladong.github.io/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%972/4.jpeg)

### 从中序与后序遍历序列构造二叉树

```c
class Solution {
private:
    // 存储 inorder 中值到索引的映射
    unordered_map<int, int> valToIndex;

public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        for (int i = 0; i < inorder.size(); i++) {
            valToIndex[inorder[i]] = i;
        }
        return build(inorder, 0, inorder.size() - 1,
                     postorder, 0, postorder.size() - 1);
    }

    /*
       定义：
       中序遍历数组为 inorder[inStart..inEnd]，
       后序遍历数组为 postorder[postStart..postEnd]，
       构造这个二叉树并返回该二叉树的根节点
    */
    TreeNode* build(vector<int>& inorder, int inStart, int inEnd,
                    vector<int>& postorder, int postStart, int postEnd) {

        if (inStart > inEnd) {
            return nullptr;
        }
        // root 节点对应的值就是后序遍历数组的最后一个元素
        int rootVal = postorder[postEnd];
        // rootVal 在中序遍历数组中的索引
        int index = valToIndex[rootVal];
        // 左子树的节点个数
        int leftSize = index - inStart;
        TreeNode* root = new TreeNode(rootVal);



        // 递归构造左右子树
        root->left = build(inorder, inStart, index - 1,
                            postorder, postStart, postStart + leftSize - 1);

        root->right = build(inorder, index + 1, inEnd,
                            postorder, postStart + leftSize, postEnd - 1);
        return root;
    }
};
```

> 分析

![](https://labuladong.github.io/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%972/5.jpeg)

![](https://labuladong.github.io/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%972/6.jpeg)

### 根据前序和后序遍历构造二叉树(无法确定唯一)

通过前序中序，或者后序中序遍历结果可以确定一棵原始二叉树，但是通过前序后序遍历结果无法确定原始二叉树

```c
preorder = [1,2,3], postorder = [3,2,1]
```
下面这两棵树都是符合条件的，但显然它们的结构不同：

![](https://labuladong.github.io/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%972/7.png)

> 步骤(左子树优先)

1、首先把前序遍历结果的第一个元素或者后序遍历结果的最后一个元素确定为根节点的值。

2、然后把前序遍历结果的第二个元素作为左子树的根节点的值。

3、在后序遍历结果中寻找左子树根节点的值，从而确定了左子树的索引边界，进而确定右子树的索引边界，递归构造左右子树即可。

```c
class Solution {
    // 存储 postorder 中值到索引的映射
    unordered_map<int, int> valToIndex;

public:
    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {
        for (int i = 0; i < postorder.size(); i++) {
            valToIndex[postorder[i]] = i;
        }
        return build(preorder, 0, preorder.size() - 1,
                     postorder, 0, postorder.size() - 1);
    }

    // 定义：根据 preorder[preStart..preEnd] 和 postorder[postStart..postEnd]
    // 构建二叉树，并返回根节点。
    TreeNode* build(vector<int>& preorder, int preStart, int preEnd,
                    vector<int>& postorder, int postStart, int postEnd) {
        if (preStart > preEnd) {
            return nullptr;
        }
        if (preStart == preEnd) {
            return new TreeNode(preorder[preStart]);
        }

        // root 节点对应的值就是前序遍历数组的第一个元素
        int rootVal = preorder[preStart];
        // root.left 的值是前序遍历第二个元素
        // 通过前序和后序遍历构造二叉树的关键在于通过左子树的根节点
        // 确定 preorder 和 postorder 中左右子树的元素区间
        int leftRootVal = preorder[preStart + 1];
        // leftRootVal 在后序遍历数组中的索引
        int index = valToIndex[leftRootVal];
        // 左子树的元素个数
        int leftSize = index - postStart + 1;

        // 先构造出当前根节点
        TreeNode* root = new TreeNode(rootVal);

        // 递归构造左右子树
        // 根据左子树的根节点索引和元素个数推导左右子树的索引边界
        root->left = build(preorder, preStart + 1, preStart + leftSize,
                           postorder, postStart, index);
        root->right = build(preorder, preStart + leftSize + 1, preEnd,
                            postorder, index + 1, postEnd - 1);

        return root;
    }
};
```


> 分析

![](https://labuladong.github.io/pictures/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%972/8.jpeg)

## 二叉树的序列化和反序列化

### 能否序列化

1. 如果你的序列化结果中不包含空指针的信息，且你只给出一种遍历顺序，那么你无法还原出唯一的一棵二叉树
2. 如果你的序列化结果中不包含空指针的信息，且你会给出两种遍历顺序，那么按照上述

> 如果你给出的是前序和中序，或者后序和中序，那么你可以还原出唯一的一棵二叉树

> 如果你给出前序和后序，那么除非你的整棵树中不包含值相同的节点，否则你无法还原出唯一的一棵二叉树

3. 如果你的序列化结果中包含空指针的信息，且你只给出一种遍历顺序，也要分两种情况

> 如果你给出的是前序或者后序，那么你可以还原出唯一的一棵二叉树

> 如果你给出的是中序，那么除非你的整棵树中不包含值相同的节点，否则你无法还原出唯一的一棵二叉树

### 实现

#### 前序遍历解法

![](https://labuladong.github.io/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BA%8F%E5%88%97%E5%8C%96/1.jpeg)

```c
string SEP = ",";
string NULL_ptr = "#";

/* 主函数，将二叉树序列化为字符串 */
string serialize(TreeNode* root) {
    string res;
    serialize(root,res);
    return res;
}

/* 辅助函数，将二叉树存入 StringBuilder */
void serialize(TreeNode* root,string& res){
    if(root == nullptr){
        res = res + NULL_ptr + SEP;
        return ;
    } 
    /****** 前序位置 ******/
    res = res + to_string(root->val) + SEP;
    /***********************/
    serialize(root->left,res);
    serialize(root->right,res);
}
```

```c
/* 主函数，将字符串反序列化为二叉树结构 */
TreeNode* deserialize(string data) {
    list<string> nodes;
    string cur = "";
    for(char &c : data){
        if(c == SEP[0]){
            nodes.push_back(cur);
            cur = "";
        }
        else 
            cur += c;
    }
    return deserialize(nodes);
}

/* 辅助函数，通过 nodes 列表构造二叉树 */
TreeNode* deserialize(list<string>& nodes){
    if(nodes.empty()) return nullptr;

    /****** 前序位置 ******/
    // 列表最左侧就是根节点
    string first = nodes.front();
    nodes.pop_front();
    if(first == NULL_ptr) return nullptr;
    TreeNode* root = new TreeNode(stoi(first));

    root->left = deserialize(nodes);
    root->right = deserialize(nodes);

    return root;
}
```

#### 后序遍历解法

![](https://labuladong.github.io/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BA%8F%E5%88%97%E5%8C%96/2.jpeg)

```c
void serialize(TreeNode root, StringBuilder sb) {
    if (root == null) {
        sb.append(NULL).append(SEP);
        return;
    }

    serialize(root.left, sb);
    serialize(root.right, sb);

    /****** 后序位置 ******/
    sb.append(root.val).append(SEP);
    /***********************/
}
```
    
```c
/* 主函数，将字符串反序列化为二叉树结构 */
TreeNode deserialize(String data) {
    LinkedList<String> nodes = new LinkedList<>();
    for (String s : data.split(SEP)) {
        nodes.addLast(s);
    }
    return deserialize(nodes);
}

/* 辅助函数，通过 nodes 列表构造二叉树 */
TreeNode deserialize(LinkedList<String> nodes) {
    if (nodes.isEmpty()) return null;
    // 从后往前取出元素
    String last = nodes.removeLast();    



    if (last.equals(NULL)) return null;
    TreeNode root = new TreeNode(Integer.parseInt(last));
    // 先构造右子树，后构造左子树
    root.right = deserialize(nodes);
    root.left = deserialize(nodes);

    return root;
}
```

#### 层级遍历

![](https://labuladong.github.io/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BA%8F%E5%88%97%E5%8C%96/3.jpeg)

```c
struct TreeNode {
   int val;
   TreeNode* left;
   TreeNode* right;
   TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  
};

string SEP = ",";
string NULL_ptr = "#";
// Encodes a tree to a single string.
string serialize(TreeNode* root) {
    if (root == nullptr) return "";
    string res;
    queue<TreeNode*> q;
    q.push(root);
    while (!q.empty()) {
        int sz = q.size();
        for (int i = 0; i < sz; i++) {
            TreeNode* cur = q.front();
            q.pop();
            if (cur == nullptr) {
                res = res + NULL_ptr + SEP;
                continue;
            }
            res = res + to_string(cur->val) + SEP;

            q.push(cur->left);
            q.push(cur->right);
        }
    }
    return res;
}

// Decodes your encoded data to tree.
TreeNode* deserialize(string data) {
    if (data.empty()) return nullptr;
    vector<string> nodes;
    string cur = "";
    for (char& c : data) {
        if (c == SEP[0]) {
            nodes.push_back(cur);
            cur = "";
        }
        else
            cur += c;
    }

    TreeNode* root = new TreeNode(stoi(nodes[0]));
    queue<TreeNode*> q;
    q.push(root);
    int idex = 1;
    while (!q.empty()) {
        int sz = q.size();
        for (int i = 0; i < sz; i++) {
            TreeNode* cur = q.front();
            q.pop();
            string left = nodes[idex++];
            if (left != NULL_ptr) {
                cur->left = new TreeNode(stoi(left));
                q.push(cur->left);
            }
            else
                cur->left = nullptr;
            string right = nodes[idex++];
            if (right != NULL_ptr) {
                cur->right = new TreeNode(stoi(right));
                q.push(cur->right);
            }
            else
                cur->right = nullptr;
        }
    }
    return root;
}
```


### 总结

1. 不论是前序遍历、中序遍历还是后序遍历，当前节点左边相对都是左子树，右边相对都是右子树
2. 前序遍历，根结点在第一个，后序遍历根结点在最后一个，中序遍历根结点左边都是左子树，右边都是右子树

## 修改二叉树

#### 合并二叉树

![image.png](https://note.youdao.com/yws/res/27453/WEBRESOURCEa7b8aa32c9b9f9776e7b3d45a938fa15)

```c
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        // 如果一棵树有，另一棵树没有，接上去
        if (!root1) {
            return root2;
        }
        if (!root2) {
            return root1;
        }
        // 两棵树都有的节点，叠加节点值
        root1->val += root2->val;
        // 递归合并左右子树
        root1->left = mergeTrees(root1->left, root2->left);
        root1->right = mergeTrees(root1->right, root2->right);

        return root1;
    }
};
```

> 分析

按照递归思路来，找到临界情况，在当前情况下，如何定义

### 后序位置妙用

**前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据**


### 实例

#### 删除给定值的叶子节点

![image.png](https://note.youdao.com/yws/res/27444/WEBRESOURCEde55b0e176d2a6893e7d24e5d482b66d)


```c
class Solution {
public:
    TreeNode* removeLeafNodes(TreeNode* root, int target) {
        if (root == nullptr) return nullptr;
        // 二叉树递归框架
        // 如果左右子节点需要被删除，先递归删除它们
        root->left = removeLeafNodes(root->left, target);
        root->right = removeLeafNodes(root->right, target);
        // 后序遍历位置，此时节点 root 直到自己是否需要被删除
        if (root->val == target && root->left == nullptr && root->right == nullptr) {
            return nullptr;
        }
        return root;
    }
};
```

> 分析

1. 如果是只删除叶子结点，应该为：

```c
class Solution {
public:
    TreeNode* removeLeafNodes(TreeNode* root, int target) {
        if (root == nullptr) return nullptr;
        // 二叉树递归框架
        //是否到叶子结点
        if (root->val == target && root->left == nullptr && root->right == nullptr) {
            return nullptr;
        }
        // 如果左右子节点需要被删除，先递归删除它们
        root->left = removeLeafNodes(root->left, target);
        root->right = removeLeafNodes(root->right, target);
        return root;
    }
};
```

2. **为什么采用后序遍历位置？**

如果采用前序遍历位置，从前往后遍历，那么该结点的子节点不确定会不会变成叶子结点且满足`target`，所以无法判断是不是要删除

如果采用后序遍历位置，从后往前遍历，那么如果该结点是叶子结点且满足`target`，那么会被置`nullptr`，对于前面的结点没影响，因为还没遍历到该结点

#### 寻找重复的子树

> 分析

想要找重复子树，要知道两点：

1、以我为根的这棵二叉树（子树）长啥样？

2、以其他节点为根的子树都长啥样？


```c
class Solution {
public:
    unordered_map<string,int> m;
    vector<TreeNode*> res;

    //1.子树自身的结构和别的子树进行对比，相同则加入
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
        traverse(root);
        return res;
    }

    string traverse(TreeNode* root){
        if(root == nullptr) return "#";

        string left = traverse(root->left);
        string right = traverse(root->right);
        
        //后序遍历
        string subTree = left + "," + right + "," + to_string(root->val);

        int num = m[subTree];

        if(num == 1){
            res.push_back(root);
            m[subTree] = num + 1;
        }
        else{
            m[subTree] = num + 1;
        }
        return subTree;
    }
};
```

# 二叉搜索树（BST）

## 概念

![image.png](https://note.youdao.com/yws/res/27446/WEBRESOURCE6aee9b0d1b8c9e7218a40729c2e9c07a)

**该结点为左子树的最大值，为右子树的最小值**

## 实例框架

对于数据结构的操作 ： 遍历 + 访问

## 二叉搜索树的增删查改

### 查

#### 二叉搜索树中的搜索

![image.png](https://note.youdao.com/yws/res/27454/WEBRESOURCEd1514f34f33471b50608460e9296fb29)

```c
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int target) {
        if (root == NULL) {
            return NULL;
        }
        // 去左子树搜索
        if (root->val > target) {
            return searchBST(root->left, target);
        }
        // 去右子树搜索
        if (root->val < target) {
            return searchBST(root->right, target);
        }
        return root;
    }
};
```

#### `floor K`

:如果当前节点不存在，则返回一个比`K`小的最大节点

```c
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int target) {
        if (root == NULL) {
            return NULL;
        }
        // 去左子树搜索
        if (root->val > target) {
            return searchBST(root->left, target);
        }
        // 去右子树搜索
        if (root->val < target) {
            TreeNode* x = searchBST(root->right, target);
            if(x == nullptr) return root;
            return x;
        }
        return root;
    }
};
```


#### `ceiling K`

:如果当前节点不存在，则返回一个比`K`大的最小节点

```c
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int target) {
        if (root == NULL) {
            return NULL;
        }
        // 去左子树搜索
        if (root->val > target) {
            TreeNode* x = searchBST(root->left, target);
            if(x == nullptr) return root;
            return x;
        }
        // 去右子树搜索
        if (root->val < target) {
            return searchBST(root->right, target);
        }
        return root;
    }
};
```

### 增

#### 二叉搜索树中的插入操作

```c
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if(root == nullptr) return new TreeNode(val);

        if(root->val > val){
            root->left = insertIntoBST(root->left,val);
        }
        if(root->val < val){
            root->right = insertIntoBST(root->right,val);
        }

        return root;
    }
};
```

> 分析

分解为子问题，如果当前节点为空，则接入该点

该点`val`值大于`root`的值，则往右边插入，否则往左边插入，最后返回根结点

### 删

#### 删除二叉搜索树中的节点


> `root`左右都非空

> 分析

分为3种情况，删除的点为子节点，只有一个非空子节点，有两个子节点

![](https://labuladong.github.io/pictures/BST/bst_deletion_case_1.png)

![](https://labuladong.github.io/pictures/BST/bst_deletion_case_2.png)

![](https://labuladong.github.io/pictures/BST/bst_deletion_case_3.png)

> 可以把左子树的最大值当成根结点，也可以把右子树的最小值当成根结点

```c
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(root == nullptr) return nullptr;

        if(root->val > key){
            root->left = deleteNode(root->left,key);
        }
        else if(root->val < key){
            root->right = deleteNode(root->right,key);
        }
        else{
            //只有左节点
            if(root->right == nullptr){
                return root->left;
            }
            //只有右节点
            if(root->left == nullptr){
                return root->right;
            }
            //左右节点都有
            TreeNode* node = maxNode(root->left);
            root->left = deleteNode(root->left,node->val);
            node->left = root->left;
            node->right = root->right;
            root = node;
        }
        return root;
    }

    TreeNode* maxNode(TreeNode* root){
        while(root->right != nullptr){
            root = root->right;
        }
        return root;
    }

};
```

### **修剪二叉搜索树**!重要!

![image.png](https://note.youdao.com/yws/res/27445/WEBRESOURCE343f1cfa03c6d99c97adbdf0d20f7277)

```c
class Solution {
public:
    // 定义：删除 BST 中小于 low 和大于 high 的所有节点，返回结果 BST
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if (root == nullptr) return nullptr;

        if (root->val < low) {
            // 直接返回 root->right
            // 等于删除 root 以及 root 的左子树
            return trimBST(root->right, low, high);
        }
        if (root->val > high) {
            // 直接返回 root->left
            // 等于删除 root 以及 root 的右子树
            return trimBST(root->left, low, high);
        }

        // 闭区间 [lo, hi] 内的节点什么都不做
        root->left = trimBST(root->left, low, high);
        root->right = trimBST(root->right, low, high);

        return root;
    }
};
```

> 分析

如果该结点数值小于最小值时，那么该结点的左子树也都小于最小值，所以都可以删除，同理大于最大值时，结点右子树都大于最大值，都可以删除

需要注意的是：如果该结点小于最小值，该结点的右子树也有不满足条件的，需要修剪


### 二叉搜索树迭代器

![image.png](https://note.youdao.com/yws/res/27452/WEBRESOURCEa68c7b0c13800ad40b98ba06bbef5fbc)

```c
class BSTIterator {
    // 模拟递归栈
    stack<TreeNode*> stk;

    // 左侧树枝一撸到底
    void pushLeftBranch(TreeNode* p) {
        while (p != nullptr) {
            stk.push(p);
            p = p->left;
        }
    }

public:
    BSTIterator(TreeNode* root) {
        pushLeftBranch(root);
    }

    int next() {
        TreeNode* p = stk.top();
        stk.pop();
        pushLeftBranch(p->right);
        return p->val;
    }

    bool hasNext() {
        return !stk.empty();
    }
};
```

### 二叉搜索树的范围和

![image.png](https://note.youdao.com/yws/res/27449/WEBRESOURCE897fced9f3056ccf278dfaf5c6e3a93f)

> 分析

可用遍历和分解的方法进行求解，利用二叉搜索树的特性，不用全部都遍历

```c
class Solution {

    int sum = 0;

    public:
    int rangeSumBST(TreeNode* root, int low, int high) {
        if (root == nullptr) return 0;
        // 遍历一遍 BST 计算区间元素和
        traverse(root, low, high);
        return sum;
    }

    void traverse(TreeNode* root, int low, int high) {
        if (root == nullptr) {
            return;
        }
        if (root->val < low) {
            // 目标区间在右子树
            traverse(root->right, low, high);
        } else if (root->val > high) {
            // 目标区间在左子树
            traverse(root->left, low, high);
        } else {
            // root->val 落在目标区间，累加 sum
            sum += root->val;
            // 继续遍历左右子树
            traverse(root->right, low, high);
            traverse(root->left, low, high);
        }
    }
}

// 分解问题的思路
class Solution2 {
    // 定义：输入一个 BST，计算值落在 [low, high] 之间的元素之和
    public:
    int rangeSumBST(TreeNode* root, int low, int high) {
        if (root == nullptr) return 0;
        if (root->val < low) {
            // 目标区间在右子树
            return rangeSumBST(root->right, low, high);
        } else if (root->val > high) {
            // 目标区间在左子树
            return rangeSumBST(root->left, low, high);
        } else {
            // 以 root 为根的这棵 BST 落在 [low, high] 之间的元素之和，
            // 等于 root->val 加上左右子树落在区间的元素之和
            return root->val
                    + rangeSumBST(root->left, low, high)
                    + rangeSumBST(root->right, low, high);
        }
    }
};
```

## 构造二叉搜索树

### 前序遍历构造二叉搜索树

```c
class Solution {
public:
    TreeNode* bstFromPreorder(vector<int>& preorder) {
        return build(preorder, 0, preorder.size() - 1);
    }

    // 定义：将 preorder[start..end] 区间内的元素生成 BST，并返回根节点
    TreeNode* build(vector<int>& preorder, int start, int end) {
        if (start > end) {
            return nullptr;
        }
        // 根据前序遍历的特点，根节点在第一位，后面接着左子树和右子树
        int rootVal = preorder[start];
        TreeNode* root = new TreeNode(rootVal);

        // 根据 BST 的特点，左子树都比根节点的值小，右子树都比根节点的值大
        // p 就是左右子树的分界点
        int p = start + 1;
        while (p <= end && preorder[p] < rootVal) {
            p++;
        }
        // [start+1, p-1] 区间内是左子树元素
        root->left = build(preorder, start + 1, p - 1);
        // [p, end] 区间内是右子树元素
        root->right = build(preorder, p, end);

        return root;
    }
};
```

> 分析

分为子问题，当前节点的情况下，什么时候满足条件：构造好二叉排序树

1. 当前数组位置为根结点
1. 找到当前数组中，哪些是左子树，哪些是右子树
2. 将左子树和右子树与创建的根结点串起来

- 重点：如何判别哪些是左子树，哪些是右子树

根据二叉排序树的性质，大于根结点为右子树，小于根结点为左子树
由于要划分哪些范围属于子树，增加二个参数，一个为初始点，一个为终止点，用来表明

## 判断是否为二叉搜索树

### **验证二叉搜索树** !重要!

![image.png](https://note.youdao.com/yws/res/27443/WEBRESOURCEb5de7e05f5b38cf34ad51c875e52d382)

> 分析

对于每一个节点 `root`，代码值检查了它的左右孩子节点是否符合左小右大的原则；但是根据 `BST` 的定义，`root` 的整个左子树都要小于 `root.val`，整个右子树都要大于 `root.val`。

##### !get!通过辅助函数，增加函数参数列表，携带额外信息

**我们通过使用辅助函数，增加函数参数列表，在参数中携带额外信息，将这种约束传递给子树的所有节点**

```c
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        // 限定以root为根的子树节点必须满足max.val > root.val > min.val 
        return checkValidBST(root, nullptr, nullptr);
    }

    // 限定root节点符合min和max的限制
    bool checkValidBST(TreeNode* root, TreeNode* minNode, TreeNode* maxNode) {
        // base case
        if (root == nullptr) return true;
        // 若root.val不符合max和min的限制，说明不是合法BST
        if (minNode != nullptr && root->val <= minNode->val) return false;
        if (maxNode != nullptr && root->val >= maxNode->val) return false;
        // 限定左子树的最大值是root.val，右子树的最小值是root.val
        return checkValidBST(root->left, minNode, root)
            && checkValidBST(root->right, root, maxNode);
    }
};
```

> 为什么要传入`null`

因为如果传入`int`类型，结点的值可以取到改值，则无法判断

### 二叉搜索树的后序遍历序列

![image.png](https://note.youdao.com/yws/res/27448/WEBRESOURCE5e9b8a7173668551fd4e38599ff612f3)

```c
class Solution {
public:
    bool verifyPostorder(vector<int>& postorder) {
        return check(postorder, 0, postorder.size() - 1);
    }

    // 定义：检查 postorder[i..j] 是否是一个合法的 BST
    bool check(vector<int>& postorder, int i, int j) {
        if (i >= j) {
            return true;
        }
        // 根节点的值是后序遍历结果的最后一个元素
        int root = postorder[j];

        // postorder[i..left) 是左子树，应该都小于 root
        int left = i;
        while (left < j && postorder[left] < root) {
            left++;
        }

        // postorder[left..j) 是右子树，应该都大于 root
        int right = left;
        while (right < j && postorder[right] > root) {
            right++;
        }
        if (right != j) {
            return false;
        }
        // 递归检查左子树 [i..left) 和右子树 [left..j) 也符合 BST 的性质
        return check(postorder, i, left - 1) && check(postorder, left, j - 1);
    }
};
```

## 利用中序遍历搜索

### 二叉搜索树中第K小的元素

![image.png](https://note.youdao.com/yws/res/27447/WEBRESOURCEdd24c7319605f7305d653a48530dbdc2)

```c
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        // 利用 BST 的中序遍历特性
        traverse(root, k);
        return res;
    }

private:
    // 记录结果
    int res = 0;
    // 记录当前元素的排名
    int rank = 0;
    void traverse(TreeNode* root, int k) {
        if (root == nullptr) {
            return;
        }
        traverse(root->left, k);
        /* 中序遍历代码位置 */
        rank++;
        if (k == rank) {
            // 找到第 k 小的元素
            res = root->val;
            return;
        }
        /*****************/
        traverse(root->right, k);
    }
};
```

### 从二叉搜索树到更大和树

![image.png](https://note.youdao.com/yws/res/27451/WEBRESOURCEbbbc7767a1c82351b4fce6b0e0ab8509)

```c
class Solution {
public:
    TreeNode* bstToGst(TreeNode* root) {
        traverse(root);
        return root;
    }

    // 记录累加和
    int sum = 0;
    void traverse(TreeNode* root) {
        if (root == nullptr) {
            return;
        }
        traverse(root->right);
        // 维护累加和
        sum += root->val;
        // 将 BST 转化成累加树
        root->val = sum;
        traverse(root->left);
    }
};
```

### 不同的二叉搜索树

![image.png](https://note.youdao.com/yws/res/27407/WEBRESOURCE78872de149d9ef7deb3cae042be23fb3)

> 分析

要求可以组成多少种二叉搜索树，以每个点为根节点时，求出左右子树可以组成多少种二叉搜索树，相乘即当前根节点能组成的二叉搜索树数目，遍历相加即可

- 时间复杂度高的做法

```c
/* 主函数 */
int numTrees(int n) {
    // 计算闭区间 [1, n] 组成的 BST 个数
    return count(1, n);
}

/* 计算闭区间 [lo, hi] 组成的 BST 个数 */
int count(int lo, int hi) {
    // base case
    if (lo > hi) return 1;

    int res = 0;
    for (int i = lo; i <= hi; i++) {
        // i 的值作为根节点 root
        int left = count(lo, i - 1);
        int right = count(i + 1, hi);
        // 左右子树的组合数乘积是 BST 的总数
        res += left * right;
    }

    return res;
}
```

因为产生了很多重叠的子问题，所以加一个备忘录，用于去除重复

- 优化方法

```c
class Solution {
public:
    // 备忘录
    int memo[20][20];

    int numTrees(int n) {
        // 备忘录的值初始化为 0
        memset(memo, 0, sizeof(memo));
        return count(1, n);
    }

    int count(int lo, int hi) {
        if (lo > hi) return 1;
        // 查备忘录
        if (memo[lo][hi] != 0) {
            return memo[lo][hi];
        }

        int res = 0;
        for (int mid = lo; mid <= hi; mid++) {
            int left = count(lo, mid - 1);
            int right = count(mid + 1, hi);
            res += left * right;
        }
        // 将结果存入备忘录
        memo[lo][hi] = res;

        return res;
    }
};
```


### 不同的二叉搜索树II

![image.png](https://note.youdao.com/yws/res/27427/WEBRESOURCEf7b505c8464cc4227e4d7347fb4ee645)

> 分析

要存储组成的二叉搜索树：

1. 穷举所有节点
2. 构造出左右子树的所有有效BST
3. 给出当前所有组合


```c
class Solution {
public:
    /* 主函数 */
    vector<TreeNode*> generateTrees(int n) {
        if (n == 0) return vector<TreeNode*>({});
        // 构造闭区间 [1, n] 组成的 BST
        return build(1, n);
    }

    /* 构造闭区间 [lo, hi] 组成的 BST */
    vector<TreeNode*> build(int lo, int hi) {
        vector<TreeNode*> res;
        // base case
        if (lo > hi) {
            res.push_back(nullptr);
            return res;
        }

        // 1、穷举 root 节点的所有可能。
        for (int i = lo; i <= hi; i++) {
            // 2、递归构造出左右子树的所有合法 BST。
            vector<TreeNode*> leftTree = build(lo, i - 1);
            vector<TreeNode*> rightTree = build(i + 1, hi);
            // 3、给 root 节点穷举所有左右子树的组合。
            for (auto left : leftTree) {
                for (auto right : rightTree) {
                    // i 作为根节点 root 的值
                    TreeNode* root = new TreeNode(i);
                    root->left = left;
                    root->right = right;
                    res.push_back(root);
                }
            }
        }
        return res;
    }
};
```

## 二叉树的最近公共祖先（`LCA`）原型

1. 后序遍历，一定会遍历二叉树的每一个节点

![image.png](https://note.youdao.com/yws/res/27474/WEBRESOURCE42e7f08ffe047d43271c0c73fe0161c1)

> 分析

比如输入这样一棵二叉树：

![](https://labuladong.github.io/algo/images/%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/2.jpg)

如果 p 是节点 6，q 是节点 7，那么它俩的 LCA 就是节点 5：

![](https://labuladong.github.io/algo/images/%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/3.jpg)

当然，p 和 q 本身也可能是 LCA，比如这种情况 q 本身就是 LCA 节点：

![](https://labuladong.github.io/algo/images/%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/4.jpg)


如果一个节点能够在它的左右子树中分别找到 p 和 q，则该节点为 LCA 节点。

1. 在 find 函数的后序位置，如果发现 left 和 right 都非空，就说明当前节点是 LCA 节点，即解决了第一种情况

2. 在 find 函数的前序位置，如果找到一个值为 val1 或 val2 的节点则直接返回，恰好解决了第二种情况

```c
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        // base case
        if (root == nullptr) return nullptr;
        if (root == p || root == q) return root;

        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        // 情况 1
        if (left != nullptr && right != nullptr) {
            return root;
        }
        // 情况 2
        if (left == nullptr && right == nullptr) {
            return nullptr;
        }
        // 情况 3
        return left == nullptr ? right : left;
    }
};
```

> 因为题目说了这些节点必定存在于二叉树中，所以可以这么判断

## 二叉树的最近公共祖先变体1

> 题目

给你输入一棵不含重复值的二叉树，输入一个包含若干节点的列表 nodes（这些节点都存在于二叉树中），让你算这些节点的最近公共祖先。这些节点必定存在于二叉树中

函数签名：

```c
TreeNode* lowestCommonAncestor(TreeNode* root, vector<TreeNode*> nodes);
```

> 解法：

```c
TreeNode lowestCommonAncestor(TreeNode root, TreeNode[] nodes) {
    // 将列表转化成哈希集合，便于判断元素是否存在
    HashSet<Integer> values = new HashSet<>();
    for (TreeNode node : nodes) {
        values.add(node.val);
    }

    return find(root, values);
}

// 在二叉树中寻找 values 的最近公共祖先节点
TreeNode find(TreeNode root, HashSet<Integer> values) {
    if (root == null) {
        return null;
    }
    // 前序位置
    if (values.contains(root.val)){
        return root;
    }

    TreeNode left = find(root.left, values);
    TreeNode right = find(root.right, values);
    // 后序位置，已经知道左右子树是否存在目标值
    if (left != null && right != null) {
        // 当前节点是 LCA 节点
        return root;
    }

    return left != null ? left : right;
}
```
 
> 因为题目说了这些节点必定存在于二叉树中，所以可以这么判断

## 二叉树的最近公共祖先变体2

> 题目

给你输入一棵不含重复值的二叉树的，以及两个节点 p 和 q，如果 p 或 q 不存在于树中，则返回空指针，否则的话返回 p 和 q 的最近公共祖先节点

> 分析

因为该题目说明，节点不一定存在于二叉树中，所以不能按前面来判断，必须要全部遍历完二叉树才知道是否存在，那应该放哪里判断呢？后序位置，因为后序位置可以遍历完整个二叉树

> 解题

```c
// 用于记录 p 和 q 是否存在于二叉树中
boolean foundP = false, foundQ = false;

TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    TreeNode res = find(root, p.val, q.val);
    if (!foundP || !foundQ) {
        return null;
    }
    // p 和 q 都存在二叉树中，才有公共祖先
    return res;
}

// 在二叉树中寻找 val1 和 val2 的最近公共祖先节点
TreeNode find(TreeNode root, int val1, int val2) {
    if (root == null) {
        return null;
    }
    TreeNode left = find(root.left, val1, val2);
    TreeNode right = find(root.right, val1, val2);

    // 后序位置，判断当前节点是不是 LCA 节点
    if (left != null && right != null) {
        return root;
    }

    // 后序位置，判断当前节点是不是目标值
    if (root.val == val1 || root.val == val2) {
        // 找到了，记录一下
        if (root.val == val1) foundP = true;
        if (root.val == val2) foundQ = true;
        return root;
    }

    return left != null ? left : right;
}
```

## 二叉树的最近公共祖先变体3

![image.png](https://note.youdao.com/yws/res/27510/WEBRESOURCEcc5c1e6510914bca8afc46f2a70436c2)

> 分析

由于是二叉搜索树，要利用其性质

```c
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == NULL) return NULL;
        if (p->val > q->val) {
            // 保证 p->val <= q->val，便于后续情况讨论
            return lowestCommonAncestor(root, q, p);
        }
        if (root->val >= p->val && root->val <= q->val) {
            // p <= root <= q
            // 即 p 和 q 分别在 root 的左右子树，那么 root 就是 LCA
            return root;
        }
        if (root->val > q->val) {
            // p 和 q 都在 root 的左子树，那么 LCA 在左子树
            return lowestCommonAncestor(root->left, p, q);
        } else {
            // p 和 q 都在 root 的右子树，那么 LCA 在右子树
            return lowestCommonAncestor(root->right, p, q);
        }
    }
};
```

## 二叉树的最近公共祖先变体4

> 题目

给你输入一棵存在于二叉树中的两个节点 p 和 q，请你返回它们的最近公共祖先，函数签名如下

```c
Node* lowestCommonAncestor(Node* p, Node* q);
```

其中：

```c
class Node {
    int val;
    Node left;
    Node right;
    Node parent;
};
```

> 分析

这道题其实不是公共祖先的问题，而是单链表相交的问题，你把 parent 指针想象成单链表的 next 指针，题目就变成了：

给你输入两个单链表的头结点 p 和 q，这两个单链表必然会相交，请你返回相交点。

> 解题

```c
Node lowestCommonAncestor(Node p, Node q) {
    // 施展链表双指针技巧
    Node a = p, b = q;
    while (a != b) {
        // a 走一步，如果走到根节点，转到 q 节点
        if (a == null) a = q;
        else           a = a.parent;
        // b 走一步，如果走到根节点，转到 p 节点
        if (b == null) b = p;
        else           b = b.parent;
    }
    return a;
}
```


## 总结

1. 对于某结点，其为左子树的最大值，为右子树的最小值
2. 中序遍历有序（因为二叉搜索树的特性，小的在左边大的在右边，而中序遍历正好满足从左到右进行遍历）
3. 左叶子结点为二叉搜索树的最小值，右叶子结点为二叉搜索树的最大值
4. 分为3种情况，删除的点为子节点，只有一个非空子节点，有两个子节点

对于删除的为子节点：直接`return nullptr`
对于删除的为一个非空子节点：返回非空子节点
对于删除的为两个子节点：可以把左子树的最大值当成根结点（替代要删除的节点），然后将该结点的`left`指向去除最大值的左子树，`right`指向右子树；也可以把右子树的最小值当成根结点

5. 我们通过使用辅助函数，增加函数参数列表，在参数中携带额外信息，将这种约束传递给子树的所有节点

比如验证二叉搜索树，通过增加参数列表，传入最大最小节点，判断该位置的节点是否位于最大最小节点值之间
