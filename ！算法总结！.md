[toc]

# !数组！

## 理论知识：
1. 数组是存放在连续内存空间上的相同类型数据的集合。 
2. 数组下标都是从0开始的。数组内存空间的地址是连续的

因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址
![image.png](https://note.youdao.com/yws/res/11160/WEBRESOURCEd3f34815b87501c001307512e7b2c28d)

> 数组的元素是不能删的，只能覆盖。

- 二维数组

![image.png](https://note.youdao.com/yws/res/11157/WEBRESOURCE6812dde6e8050a754f866fdf9330425f)

> 二维数组在内存的空间地址是连续的吗？

在c++中二维数组是连续分布的

```c
void test_arr() {
    int array[2][3] = {
		{0, 1, 2},
		{3, 4, 5}
    };
    cout << &array[0][0] << " " << &array[0][1] << " " << &array[0][2] << endl;
    cout << &array[1][0] << " " << &array[1][1] << " " << &array[1][2] << endl;
}

int main() {
    test_arr();
}
```

结果：
```c
0x7ffee4065820 0x7ffee4065824 0x7ffee4065828
0x7ffee406582c 0x7ffee4065830 0x7ffee4065834
```

![image.png](https://note.youdao.com/yws/res/11162/WEBRESOURCEcdb95a6fe584496e6239876949648b5a)

**处理数组和链表相关问题，常用到的双指针技巧为：<font color=red>左右指针和快慢指针</font>**

所谓左右指针，就是两个指针相向而行或者相背而行；而所谓快慢指针，就是两个指针同向而行，一快一慢。

## 快慢指针

### 适用场景
<font color=red>
！**数组问题中比较常见的快慢指针技巧，是让你原地修改数组。**！

！**除了让你在有序数组/链表中去重，题目还可能让你对数组中的某些元素进行「原地删除」。**！
！**滑动窗口算法**！left 指针在后，right 指针在前，两个指针中间的部分就是「窗口」，算法通过扩大和缩小「窗口」来解决某些问题</font>

### 原地修改数组
例题：26题 https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/

![image.png](https://note.youdao.com/yws/res/11158/WEBRESOURCEe898595b77d7995813287d2924ed718e)

我们让慢指针 slow 走在后面，快指针 fast 走在前面探路，找到一个不重复的元素就赋值给 slow 并让 slow 前进一步。

```c
int removeDuplicates(vector<int>& nums) {
    if (nums.size() == 0) {
        return 0;
    }
    int slow = 0, fast = 0;
    while (fast < nums.size()) {
        if (nums[fast] != nums[slow]) {
            slow++;
            // 维护 nums[0..slow] 无重复
            nums[slow] = nums[fast];
        }
        fast++;
    }
    // 数组长度为索引 + 1
    return slow + 1;
}
```
![](https://labuladong.github.io/algo/images/%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d/1.gif)

#### **自我总结**
维护两个指针，一个快指针，一个慢指针，快指针每次循环往前一步，慢指针遇到符合条件的往前一步。

### 滑动窗口

#### 使用场景
寻找一个区间内满足条件的一小个区间，常出现在`子串`、`子数组`问题中

#### 大致框架
这个算法技巧的思路非常简单，就是维护一个窗口，不断滑动，然后更新答案。

```c
/* 滑动窗口算法框架 */
void slidingWindow(string s) {
    unordered_map<char, int> window;

    int left = 0, right = 0;
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 增大窗口
        right++;
        // 进行窗口内数据的一系列更新
        ...

        /*** debug 输出的位置 ***/
        printf("window: [%d, %d)\n", left, right);
        /********************/

        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            // 缩小窗口
            left++;
            // 进行窗口内数据的一系列更新
            ...
        }
    }
}
```

#### 示例

![image.png](https://note.youdao.com/yws/res/11708/WEBRESOURCEc71c0a9aa727a8a8775c136d9036394d)

要在 `S(source)` 中找到包含 `T(target)` 中全部字母的一个子串，且这个子串一定是所有可能子串中最短的。

1. 我们在字符串 `S` 中使用双指针中的左右指针技巧，初始化 `left = right = 0`，把索引左闭右开区间 `[left, right)` 称为一个「窗口」。

2. 我们先不断地增加 `right` 指针扩大窗口 `[left, right)`，直到窗口中的字符串符合要求（包含了 `T` 中的所有字符）。
3. 此时，我们停止增加 `right`，转而不断增加 `left` 指针缩小窗口 `[left, right)`，直到窗口中的字符串不再符合要求（不包含 `T` 中的所有字符了）。同时，每次增加 `left`，我们都要更新一轮结果。
4. 重复第 `2` 和第 `3` 步，直到 `right` 到达字符串 `S` 的尽头。


下面画图理解一下，`needs` 和 `window` 相当于计数器，分别记录 `T` 中字符出现次数和「窗口」中的相应字符的出现次数。

初始状态：

![image.png](https://note.youdao.com/yws/res/11721/WEBRESOURCE33b1a349a4ae49dc663676d09d2f2afd)

增加 `right`，直到窗口 `[left, right)` 包含了 `T` 中所有字符：

![image.png](https://note.youdao.com/yws/res/11726/WEBRESOURCE42574fe38456258455ce789d4e7d79b3)

现在开始增加 `left`，缩小窗口 `[left, right)`：
![image.png](https://note.youdao.com/yws/res/11729/WEBRESOURCE03927ca6a0e2f76464a349518f7a9f2e)

直到窗口中的字符串不再符合要求，`left` 不再继续移动：

![image.png](https://note.youdao.com/yws/res/11732/WEBRESOURCE31771138f9326d891eb02e6d28bd3b95)


首先，初始化 `window` 和 `need` 两个哈希表，记录窗口中的字符和需要凑齐的字符：

```c
unordered_map<char, int> need, window;
for (char c : t) need[c]++;
```

然后，使用 `left` 和 `right` 变量初始化窗口的两端，不要忘了，区间 `[left, right)` 是左闭右开的，所以初始情况下窗口没有包含任何元素：

```c
int left = 0, right = 0;
int valid = 0; 
while (right < s.size()) {
    // 开始滑动
}
```

其中 `valid` 变量表示窗口中满足 `need` 条件的字符个数，如果 `valid` 和 `need.size` 的大小相同，则说明窗口已满足条件，已经完全覆盖了串 `T`。

现在开始套模板，只需要思考以下几个问题：

1、什么时候应该移动 `right` 扩大窗口？窗口加入字符时，应该更新哪些数据？

2、什么时候窗口应该暂停扩大，开始移动 `left` 缩小窗口？从窗口移出字符时，应该更新哪些数据？

3、我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？

如果一个字符进入窗口，应该增加 `window` 计数器；如果一个字符将移出窗口的时候，应该减少 `window` 计数器；当 `valid` 满足 `need` 时应该收缩窗口；应该在收缩窗口的时候更新最终结果。

下面是完整代码：

```c
string minWindow(string s, string t) {
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++;

    int left = 0, right = 0;    
    int valid = 0;
    // 记录最小覆盖子串的起始索引及长度
    int start = 0, len = INT_MAX;
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 扩大窗口
        right++;
        // 进行窗口内数据的一系列更新
        if (need.count(c)) {
            window[c]++;
            if (window[c] == need[c])
                valid++;
        }

        // 判断左侧窗口是否要收缩
        while (valid == need.size()) {            
            // 在这里更新最小覆盖子串
            if (right - left < len) {
                start = left;
                len = right - left;
            }
            // d 是将移出窗口的字符
            char d = s[left];
            // 缩小窗口
            left++;
            // 进行窗口内数据的一系列更新
            if (need.count(d)) {
                if (window[d] == need[d])
                    valid--;
                window[d]--;
            }                    
        }        
    }
    // 返回最小覆盖子串
    return len == INT_MAX ?
        "" : s.substr(start, len);
}
```

> 例题

![image.png](https://note.youdao.com/yws/res/13551/WEBRESOURCE5bbb347d1f98b5994722dab182a53367)

1、当窗口内元素之和小于目标和 `target` 时，扩大窗口，窗口内元素

2、当窗口内元素之和大于目标和 `target` 时，缩小窗口，空余出更多可替换次数。

3、当窗口内元素之和等于目标和 `target` 时，找到一个符合条件的子数组，我们想找的是最长的子数组长度。

注意：之所以本题可以用滑动窗口，关键是题目说了 `nums` 中的元素都是正数，这就保证了只要有元素加入窗口，和一定变大，只要有元素离开窗口，和一定变小。

```c
class Solution {
public:
    int minOperations(vector<int>& nums, int x) {
        int n = nums.size(), sum = 0;
        for (int i = 0; i < n; i++) {
            sum += nums[i];
        }
        // 滑动窗口需要寻找的子数组目标和
        int target = sum - x;

        int left = 0, right = 0;
        // 记录窗口内所有元素和
        int windowSum = 0;
        // 记录目标子数组的最大长度
        int maxLen = INT_MIN;
        // 开始执行滑动窗口框架
        while (right < n) {
            // 扩大窗口
            windowSum += nums[right];
            right++;

            while (windowSum > target && left < right) {
                // 缩小窗口
                windowSum -= nums[left];
                left++;
            }
            // 寻找目标子数组
            if (windowSum == target) {
                maxLen = max(maxLen, right - left);
            }
        }
        // 目标子数组的最大长度可以推导出需要删除的字符数量
        return maxLen == INT_MIN ? -1 : n - maxLen;
    }
};
```

![image.png](https://note.youdao.com/yws/res/13639/WEBRESOURCEa352d513dbec9a1cce4c16ea03c2b31c)

分析：怎么找？要换一个思路，满足条件的时候是什么情况？即：长度为K子数组，包含至少2个重复元素，则满足条件，否则不满足

```c
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        int left = 0, right = 0;
        unordered_set<int> window;
        // 滑动窗口算法框架，维护一个大小为 k 的窗口
        while (right < nums.size()) {
            // 扩大窗口
            if (window.count(nums[right])) {
                return true;
            }
            window.insert(nums[right]);
            right++;

            if (right - left > k) {
                // 当窗口的大小大于 k 时，缩小窗口
                window.erase(nums[left]);
                left++;
            }
        }
        return false;
    }
};
```


![image.png](https://note.youdao.com/yws/res/13642/WEBRESOURCEaa04b23275896d6e99c0376c381ffe8b)


分析：本题按照以往滑动窗口的方法，无法判断什么时候扩大窗口，什么时候缩小窗口，但是可以添加一个约束，使之能将窗口进行收缩：求每个字符都出现至少 k 次，仅包含 count 种不同字符的最长子串。

1、什么时候应该扩大窗口？窗口中字符种类小于 count 时扩大窗口。

2、什么时候应该缩小窗口？窗口中字符种类大于 count 时扩大窗口。

3、什么时候得到一个合法的答案？窗口中所有字符出现的次数都大于等于 k 时，得到一个合法的子串。

题目没有 count 的约束，那没关系呀，count 能有几种取值？因为 s 中只包含小写字母，所以 count 的取值也就是 1~26，所以最后用一个 for 循环把这些值都输入 logestKLetterSubstr 计算一遍，求最大值就是题目想要的答案了。


```c
int longestSubstring(string s, int k) {
    int len = 0;
    for (int i = 1; i <= 26; i++) {
        len = max(logestKLetterSubstr(s, k,i), len);
    }
    return len;
}


int logestKLetterSubstr(string s, int k, int count) {
    int left = 0; int right = 0;
    int haveCount = 0;
    int artCount = 0;
    int maxCount = 0;
    vector<int>windows(26);
    while (right < s.size())
    {
        char c1 = s[right];
        if (windows[c1 - 'a'] == 0)haveCount++;
        windows[c1 - 'a']++;
        if (windows[c1 - 'a'] == k) artCount++;
        right++;
        while (haveCount > count)
        {
            char c2 = s[left];
            if (windows[c2 - 'a'] == k) artCount--;
            windows[c2 - 'a']--;
            if (windows[c2 - 'a'] == 0) haveCount--;
            left++;
        }
        if (artCount == count) maxCount = max(maxCount, right - left);
    }
    return maxCount;
}
```

#### 自我总结

使用场景：寻找一个区间内满足条件的一小个区间,常出现在子串、子数组问题中
增加了元素或者减小了元素，即扩大或缩小窗口，其一定要满足要求（线性变化）

根据如下步骤：

1. 什么时候应该扩大窗口？

2. 什么时候应该缩小窗口？

3. 什么时候得到一个合法的答案？


框架：
```c
/* 滑动窗口算法框架 */
void slidingWindow(string s) {
    unordered_map<char, int> window;

    int left = 0, right = 0;
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 增大窗口
        right++;
        // 进行窗口内数据的一系列更新
        ...

        /*** debug 输出的位置 ***/
        printf("window: [%d, %d)\n", left, right);
        /********************/

        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            // 缩小窗口
            left++;
            // 进行窗口内数据的一系列更新
            ...
        }
    }
}
```

**思路**：

1. 初始化左右指针，把索引区间用左闭右开的形式，再初始化`Window`窗口。有时也需要初始化`Need`窗口（需要的字符串）。

2. `right`指针不断向右移，直至字符串最后一个。

3. 在`步骤2`增加`right`指针中：判断`left`指针是否要收缩的条件

4. 不满足->不断扩大至符合窗口中的字符串要求。此时需要对窗口内的数据进行更新。
   满足 -> `left`指针右移，不断缩小窗口，对窗口的数据进行更新

5. 在收缩窗口时，或者收缩窗口后，需要更新最终的结果


需要注意的地方：

1. int 类型的最大值用INT_MAX表示
2. unordered_map的成员函数count()，只有0或1，0表示没有该元素，反之1表示有。
3. 要特别注意左侧窗口收缩的条件和对结果的更新


> 举例：

![image.png](https://note.youdao.com/yws/res/11804/WEBRESOURCE3e315274729e7964dec90183b7d22f1f)

此时左侧窗口更新的条件为：

`right - left >= t.size()`，因为要保持窗口内的字符串长度要大于子串的长度

此时结果更新应该为：

```c
while (right - left >= t.size()) {
            // 在这里判断是否找到了合法的子串
            if (valid == need.size())
                return true;
            char d = s[left];
            left++;
            // 进行窗口内数据的一系列更新
            if (need.count(d)) {
                if (window[d] == need[d])
                    valid--;
                window[d]--;
            }
```

![image.png](https://note.youdao.com/yws/res/11818/WEBRESOURCE607029b18a9fea5966f715a370e0cdef)

此时左侧窗口更新的条件为：`(window[c] > 1)`,因为不能包含重复的字符

此时结果更新应该为：
```c
 while (window[c] > 1) {
            char d = s[left];
            left++;
            // 进行窗口内数据的一系列更新
            window[d]--;
        }
        // 在这里更新答案
        res = max(res, right - left);
```

### 反转字符串中的单词

![image.png](https://note.youdao.com/yws/res/13284/WEBRESOURCE0a6914ad90f4946e35d18f00799d327c)

分析：最常见的方法是去掉多余的空格，将整个字符串`s`反转，将单个单词反转，但是额外空间复杂度较高。

可以考虑用快慢指针，重点在于去空行这个操作！

```c
class Solution {
public:
    void reverse(string& s, int start, int end){ //翻转，区间写法：左闭又闭 []
        for (int i = start, j = end; i < j; i++, j--) {
            swap(s[i], s[j]);
        }
    }

    void removeExtraSpaces(string& s) {//去除所有空格并在相邻单词之间添加空格, 快慢指针。
        int slow = 0; 
        for (int i = 0; i < s.size(); ++i) { //
            if (s[i] != ' ') { //遇到非空格就处理，即删除所有空格。
                if (slow != 0) s[slow++] = ' '; //手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。
                while (i < s.size() && s[i] != ' ') { //补上该单词，遇到空格说明单词结束。
                    s[slow++] = s[i++];
                }
            }
        }
        s.resize(slow); //slow的大小即为去除多余空格后的大小。
    }

    string reverseWords(string s) {
        removeExtraSpaces(s); //去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。
        reverse(s, 0, s.size() - 1);
        int start = 0; //removeExtraSpaces后保证第一个单词的开始下标一定是0。
        for (int i = 0; i <= s.size(); ++i) {
            if (i == s.size() || s[i] == ' ') { //到达空格或者串尾，说明一个单词结束。进行翻转。
                reverse(s, start, i - 1); //翻转，注意是左闭右闭 []的翻转。
                start = i + 1; //更新下一个单词的开始下标start
            }
        }
        return s;
    }
};

```

注意：

去空格这个操作，遇到非空格就处理，在这个循环里面遍历完单个单词，然后加空格，字符串中`i`不断在移动，`slow`只有在非空格和读完单个单词加空格时移动。

反转单个单词操作，定义一个指针指向下一个单词的开始

### 顺/逆时针旋转矩阵

![](https://labuladong.github.io/algo/images/%e8%8a%b1%e5%bc%8f%e9%81%8d%e5%8e%86/title.png)

题目很好理解，就是让你将一个二维矩阵顺时针旋转 90 度，难点在于要「原地」修改，函数签名如下：

```c
void rotate(vector<vector<int>>& matrix)
```

顺时针旋转二维矩阵的问题，常规的思路就是去寻找原始坐标和旋转后坐标的映射规律(但是不能满足原地修改)，但我们是否可以让思维跳跃跳跃，尝试把矩阵进行反转、镜像对称等操作，可能会出现新的突破口。

旋转二维矩阵的难点在于将「行」变成「列」，将「列」变成「行」，而只有按照对角线的对称操作是可以轻松完成这一点的，对称操作之后就很容易发现规律了。

我们可以先将 `n x n `矩阵 `matrix` 按照左上到右下的对角线进行镜像对称：

![](https://labuladong.github.io/algo/images/%e8%8a%b1%e5%bc%8f%e9%81%8d%e5%8e%86/2.jpeg)

然后再对矩阵的每一行进行反转：

![](https://labuladong.github.io/algo/images/%e8%8a%b1%e5%bc%8f%e9%81%8d%e5%8e%86/3.jpeg)

发现结果就是` matrix` 顺时针旋转 `90` 度的结果：

![](https://labuladong.github.io/algo/images/%e8%8a%b1%e5%bc%8f%e9%81%8d%e5%8e%86/4.jpeg)

```c
void rotate(vector<vector<int>>& matrix) {
    int n = matrix.size();
    // 先沿对角线镜像对称二维矩阵
    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            // swap(matrix[i][j], matrix[j][i]);
            int temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }
    // 然后反转二维矩阵的每一行
    for (vector<int>& row : matrix) {
        reverse(row.begin(), row.end());
    }
}

// 反转一维数组
void reverse(vector<int>& arr) {
    int i = 0, j = arr.size() - 1;
    while (j > i) {
        // swap(arr[i], arr[j]);
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
        i++;
        j--;
    }
}
```

如何将矩阵逆时针旋转 90 度呢？

思路是类似的，只要通过另一条对角线镜像对称矩阵，然后再反转每一行，就得到了逆时针旋转矩阵的结果：

![](https://labuladong.github.io/algo/images/%e8%8a%b1%e5%bc%8f%e9%81%8d%e5%8e%86/5.jpeg)

## 左右指针

### 适用场景
<font color=red>

！**二分查找**！
！**两数之和**！
！**反转数组**！
！**回文串判断**！

</font>

### 二分查找

#### 适用场景

<font color=red>

二分搜索的套路比较固定，如果遇到一个算法问题，能够确定 x, f(x), target 分别是什么，并写出单调函数 f 的代码

</font>

> 注意事项：
1. 到底要给 `mid` 加一还是减一，`while` 里到底用 `<=` 还是 `<`。
2. 计算 `mid` 时需要防止溢出，代码中 `left + (right - left) / 2` 就和 `(left + right) / 2` 的结果相同，但是有效防止了 `left` 和 `right` 太大，直接相加导致溢出的情况。

#### 使用场景
**寻找一个数、寻找左侧边界、寻找右侧边界**

#### 大致框架
```c
int binarySearch(int[] nums, int target) {
    int left = 0, right = ...;

    while(...) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            ...
        } else if (nums[mid] < target) {
            left = ...
        } else if (nums[mid] > target) {
            right = ...
        }
    }
    return ...;
}
```

#### 类型

- **寻找一个数**


```c
int binarySearch(int[] nums, int target) {
    int left = 0; 
    int right = nums.length - 1; // 注意

    while(left <= right) {
        int mid = left + (right - left) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] < target)
            left = mid + 1; // 注意
        else if (nums[mid] > target)
            right = mid - 1; // 注意
    }
    return -1;
}
```

> 问题：

1. 为什么 `while` 循环的条件中是 <=，而不是 <？
答：
因为初始化 `right` 的赋值是 `nums.length - 1`，即最后一个元素的索引，而不是 `nums.length`。
前者相当于两端都闭区间 `[left, right]`，后者相当于左闭右开区间 `[left, right)`，因为索引大小为 `nums.length` 是越界的。
**使用的是前者 `[left, right]` 两端都闭的区间。这个区间其实就是每次进行搜索的区间**
那 `while` 循环什么时候应该终止？搜索区间为空的时候应该终止
`while(left <= right)` 的终止条件是 `left == right + 1`，写成区间的形式就是 `[right + 1, right]`，或者带个具体的数字进去 `[3, 2]`，可见这时候区间为空
`while(left < right)`的终止条件是 `left == right`，写成区间的形式就是 `[right, right]`，或者带个具体的数字进去 `[2, 2]`，这时候区间非空，还有一个数 `2`，但此时 `while` 循环终止了。也就是说这区间 `[2, 2]` 被漏掉了，索引 `2` 没有被搜索，如果这时候直接返回 `-1` 就是错误的

2. 为什么 `left = mid + 1`，`right = mid - 1`

本算法的搜索区间是两端都闭的，即` [left, right]`,当然是去搜索区间 `[left, mid-1]` 或者区间 `[mid+1, right]` 对不对？因为` mid `已经搜索过，应该从搜索区间中去除。

> 缺陷：

比如说给你有序数组 `nums = [1,2,2,2,3]`，`target` 为 `2`，此算法返回的索引是 `2`，没错。但是如果我想得到 `target` 的左侧边界，即索引 `1`，或者我想得到 `target` 的右侧边界，即索引`3`，这样的话此算法是无法处理的。

- **寻找左侧边界的二分搜索**

```c
int left_bound(int[] nums, int target) {
    int left = 0;
    int right = nums.length; // 注意
    
    while (left < right) { // 注意
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            right = mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid; // 注意
        }
    }
    return left;
}
```

> 问题：

1. 为什么 `while` 中是 `<` 而不是 `<=`?
因为 `right = nums.length `而不是 `nums.length - 1`。因此每次循环的「搜索区间」是 `[left, right)` 左闭右开。`while(left < right)` 终止的条件是 `left == right`，此时搜索区间 `[left, left)` 为空，所以可以正确终止。

2. 为什么没有返回 -1 的操作？如果 nums 中不存在 target 这个值，怎么办？
在返回的时候额外判断一下 `nums[left]` 是否等于 `arget` 就行了，如果不等于，就说明 `target` 不存在。不过我们得考察一下 `left` 的取值范围，免得索引越界。假如输入的 `target` 非常大，那么就会一直触发 `nums[mid] < target` 的 if 条件，`left` 会一直向右侧移动，直到等于 `right`，`while` 循环结束。

```c
while (left < right) {
    //...
}
// 此时 target 比所有数都大，返回 -1
if (left == nums.length) return -1;
// 判断一下 nums[left] 是不是 target
return nums[left] == target ? left : -1;
```

3. 为什么` left = mid + 1`，`right = mid` ？和之前的算法不一样？
因为我们的「搜索区间」是 `[left, right)` 左闭右开，所以当 `nums[mid]` 被检测之后，下一步应该去` mid` 的左侧或者右侧区间搜索，即` [left, mid)` 或` [mid + 1, right)`。

4. 为什么返回 `left` 而不是`right`？
都是一样的，因为 `while` 终止的条件是 `left == right`。


5. 能不能想办法把 `right` 变成 `nums.length - 1`，也就是继续使用两边都闭的「搜索区间」？这样就可以和第一种二分搜索在某种程度上统一起来了。
你非要让搜索区间两端都闭，所以 `right `应该初始化为 `nums.length - 1`，`while` 的终止条件应该是 `left == right + 1`，也就是其中应该用 `<=`：

```c
int left_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    // 搜索区间为 [left, right]
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            // 搜索区间变为 [mid+1, right]
            left = mid + 1;
        } else if (nums[mid] > target) {
            // 搜索区间变为 [left, mid-1]
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 收缩右侧边界
            right = mid - 1;
        }
    }
    // 判断 target 是否存在于 nums 中
    // 此时 target 比所有数都大，返回 -1
    if (left == nums.length) return -1;
    // 判断一下 nums[left] 是不是 target
    return nums[left] == target ? left : -1;
```

- **寻找右侧边界的二分查找**

```c
int right_bound(int[] nums, int target) {
    int left = 0, right = nums.length;
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            left = mid + 1; // 注意
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid;
        }
    }
    return left - 1; // 注意
```

> 只有两处和左侧边界不同

> 问题：

1. 为什么这个算法能够找到右侧边界？
```c
if (nums[mid] == target) {
    left = mid + 1;
```

当 `nums[mid] == target` 时，不要立即返回，而是增大「搜索区间」的左边界 `left`，使得区间不断向右靠拢，达到锁定右侧边界的目的
> 注意，此时是`left = mid + 1;`而不是`left = mid；`所以才导致后面的`left - 1`

2. 为什么最后返回 `left - 1` 而不像左侧边界的函数，返回 `left`？而且我觉得这里既然是搜索右侧边界，应该返回 `right` 才对

while 循环的终止条件是 `left == right`，所以 `left` 和 `right` 是一样的，你非要体现右侧的特点，返回 `right - 1` 好了。

```c
// 增大 left，锁定右侧边界
if (nums[mid] == target) {
    left = mid + 1;
    // 这样想: mid = left - 1
```

因为我们对 `left `的更新必须是 `left = mid + 1`，就是说` while` 循环结束时，`nums[left]` 一定不等于` target` 了，而 `nums[left-1]` 可能是 `target`。

3. 为什么没有返回 -1 的操作？如果 nums 中不存在 target 这个值，怎么办？
```
while (left < right) {
    // ...
}
// 判断 target 是否存在于 nums 中
// 此时 left - 1 索引越界
if (left - 1 < 0) return -1;
// 判断一下 nums[left] 是不是 target
return nums[left - 1] == target ? (left - 1) : -1;
```

4. 是否也可以把这个算法的「搜索区间」也统一成两端都闭的形式呢？

```c
int right_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 这里改成收缩左侧边界即可
            left = mid + 1;
        }
    }
    // 最后改成返回 left - 1
    if (left - 1 < 0) return -1;
    return nums[left - 1] == target ? (left - 1) : -1;
}
```


#### 逻辑统一

> ！**经验**！

1. **计算左边界，`right`向左逼近，计算右边界，`left`向右逼近**
2. **如果当`right = nums.size()-1`时，那么循环条件为 `left <= right`，此时是`[]`左闭右闭的区间，如果`right = nums.size();`那么循环条件为 `left < right`，此时是`[）`左闭右开的区间**。
3. 根据区间来判断，如果`right = nums.size() -1`,那么
> 左边界：

**`right = mid -1;`,`left = mid +1;`。因为左闭右闭，所以跳过`mid`单元，因为已经比较过**。**`return left`**，因为此时跳过循环的条件为`left = right +1;`,所以根据当`nums[mid] ==target`时，条件为`right = mid - 1`，判断此时`left == mid`，故返回`left`。

> 右边界
`right = mid -1;`,`left = mid +1;`。因为左闭右闭，所以跳过`mid`单元。
**`return left - 1`**，因为当`nums[mid] ==target`时，条件为`left = mid + 1`，判断此时`left = mid +1 `，所以返回`left -1`。

3. 如果`right = nums.size()`，那么

> 左边界：

**`right = mid;`,`left = mid +1;`**。因为左闭右开，所以当为`right = mid -1`时，[x,mid-1)，此时取不到，所以无法判断该点是否等于`target`。**`return left`**，因为此时跳过循环的条件为`left == right;`,所以根据当`nums[mid] == target`时，`right == mid`，判断此时`left == mid`，所以返回`left`。

> 右边界：

`right = mid;`,`left = mid +1;`。因为左闭右开。**`return left -1`**，因为此时跳过循环的条件为`left == right；`，所以根据当`nums[mid] == target`时，`left == mid + 1；`，判断此时`left = mid + 1`，所以返回`left -1`。


```c
int binary_search(int[] nums, int target) {
    int left = 0, right = nums.length - 1; 
    while(left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1; 
        } else if(nums[mid] == target) {
            // 直接返回
            return mid;
        }
    }
    // 直接返回
    return -1;
}

int left_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 别返回，锁定左侧边界
            right = mid - 1;
        }
    }
    // 判断 target 是否存在于 nums 中
    // 此时 target 比所有数都大，返回 -1
    if (left == nums.length) return -1;
    // 判断一下 nums[left] 是不是 target
    return nums[left] == target ? left : -1;
}

int right_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 别返回，锁定右侧边界
            left = mid + 1;
        }
    }
    // 此时 left - 1 索引越界
    if (left - 1 < 0) return -1;
    // 判断一下 nums[left] 是不是 target
    return nums[left - 1] == target ? (left - 1) : -1;
}
```

> 例题

![image.png](https://note.youdao.com/yws/res/14642/WEBRESOURCE51d99ae21b1975acf99c9b72547aa14b)

我们计算 `nums[mid]` 和 `nums[mid+1]` 这两个元素的相对大小，即可得到 `mid` 附近的元素走势：

如果走势下行`（nums[mid] > nums[mid+1]`），说明 `mid` 本身就是峰值或其左侧有一个峰值，所以需要收缩右边界`（right = mid）`；

如果走势上行`（nums[mid] < nums[mid+1]`），则说明 `mid` 右侧有一个峰值，需要收缩左边界`（left = mid + 1）`。

因为题目说了 `nums` 中不存在相等的相邻元素，所以不用考虑 `nums[mid] == nums[mid+1]` 的情况，依据以上分析即可写出代码。

```c
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        // 取两端都闭的二分搜索
        int left = 0, right = nums.size() - 1;
        // 因为题目必然有解，所以设置 left == right 为结束条件
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > nums[mid + 1]) {
                // mid 本身就是峰值或其左侧有一个峰值
                right = mid;
            } else {
                // mid 右侧有一个峰值
                left = mid + 1;
            }
        }
        return left;
    }
};
```

#### 抽象成图像

- 搜索左侧边界

![image.png](https://note.youdao.com/yws/res/11159/WEBRESOURCEd96cea3b421e0010796c70e5d0a0fe41)

- 搜索右侧边界

![image.png](https://note.youdao.com/yws/res/11161/WEBRESOURCE0bc6201743000d84a22d1fbd62d42300)

####  ！二分搜索问题的泛化！重点

**首先，要从题目中抽象出一个自变量 `x`，一个关于 `x` 的函数 `f(x)`，以及一个目标值 `target`。**
同时，`x`, `f(x)`, `target` 还要满足以下条件：

1. `f(x)` 必须是在 x 上的单调函数（单调增单调减都可以）。

2. 题目是让你计算满足约束条件 `f(x) == target` 时的 `x` 的值。


> 举个具体的例子:

给你一个升序排列的有序数组 `nums` 以及一个目标元素 `target`，请你计算 `target` 在数组中的索引位置，如果有多个目标元素，返回最小的索引。

[搜索左侧边界」这个基本题型,这里面 `x`, `f(x)`, `target` 分别是什么呢？

可以把数组中元素的索引认为是自变量 `x`，函数关系 `f(x)` 就可以这样设定:

```c
// 函数 f(x) 是关于自变量 x 的单调递增函数
// 入参 nums 是不会改变的，所以可以忽略，不算自变量
int f(int x, int[] nums) {
    return nums[x];
}
```

其实这个函数 `f `就是在访问数组` nums`，因为题目给我们的数组 `nums` 是升序排列的，所以函数 `f(x)` 就是在 `x` 上单调递增的函数。

让我们计算元素 `target` 的最左侧索引 -> 是不是就相当于在问我们「满足 `f(x) == target` 的 `x` 的最小值是多少」？

![image.png](https://note.youdao.com/yws/res/11189/WEBRESOURCE60884b296db6d667cf1103b2fad3fc16)

**如果遇到一个算法问题，能够把它抽象成这幅图，就可以对它运用二分搜索算法。**

代码如下：

```c
// 函数 f 是关于自变量 x 的单调递增函数
int f(int x, int[] nums) {
    return nums[x];
}

int left_bound(int[] nums, int target) {
    if (nums.length == 0) return -1;
    int left = 0, right = nums.length;

    while (left < right) {
        int mid = left + (right - left) / 2;
        if (f(mid, nums) == target) {
            // 当找到 target 时，收缩右侧边界
            right = mid;
        } else if (f(mid, nums) < target) {
            left = mid + 1;
        } else if (f(mid, nums) > target) {
            right = mid;
        }
    }
    return left;
}
```

#### **运用二分搜索的套路框架**

```c
// 函数 f 是关于自变量 x 的单调函数
int f(int x) {
    // ...
}

// 主函数，在 f(x) == target 的约束下求 x 的最值
int solution(int[] nums, int target) {
    if (nums.length == 0) return -1;
    // 问自己：自变量 x 的最小值是多少？
    int left = ...;
    // 问自己：自变量 x 的最大值是多少？
    int right = ... + 1;

    while (left < right) {
        int mid = left + (right - left) / 2;
        if (f(mid) == target) {
            // 问自己：题目是求左边界还是右边界？
            // ...
        } else if (f(mid) < target) {
            // 问自己：怎么让 f(x) 大一点？
            // ...
        } else if (f(mid) > target) {
            // 问自己：怎么让 f(x) 小一点？
            // ...
        }
    }
    return left;
}
```

分为以下几步：

1、确定 `x`,`f(x)`, `target` 分别是什么，并写出函数 `f` 的代码。

2、找到 `x` 的取值范围作为二分搜索的搜索区间，初始化 `left` 和 `right` 变量。

3、根据题目的要求，确定应该使用搜索左侧还是搜索右侧的二分搜索算法，写出解法代码。

> 典型例题：

![image.png](https://note.youdao.com/yws/res/11201/WEBRESOURCE3b10c774e05a81e576eed234b582a2c3)


珂珂每小时最多只能吃一堆香蕉，如果吃不完的话留到下一小时再吃；如果吃完了这一堆还有胃口，也只会等到下一小时才会吃下一堆。

他想在警卫回来之前吃完所有香蕉，让我们确定吃香蕉的最小速度 `K`。

函数如下：

```int minEatingSpeed(int[] piles, int H);```

按步骤思考即可：

1. 确定 `x`, `f(x)`, `target` 分别是什么，并写出函数 `f` 的代码。
自变量 `x` 是什么呢？回忆之前的函数图像，二分搜索的本质就是在搜索自变量。
所以，题目让求什么，就把什么设为自变量，珂珂吃香蕉的速度就是自变量 `x`。
那么，在 `x` 上单调的函数关系 `f(x)` 是什么？
显然，吃香蕉的速度越快，吃完所有香蕉堆所需的时间就越少，速度和时间就是一个单调函数关系。
所以，`f(x)` 函数就可以这样定义：
若吃香蕉的速度为 `x` 根/小时，则需要 `f(x)` 小时吃完所有香蕉。

代码实现如下

```c
// 定义：速度为 x 时，需要 f(x) 小时吃完所有香蕉
// f(x) 随着 x 的增加单调递减
int f(int[] piles, int x) {
    int hours = 0;
    for (int i = 0; i < piles.length; i++) {
        hours += piles[i] / x;
        if (piles[i] % x > 0) {
            hours++;
        }
    }
    return hours;
}
```

2. 找到 `x` 的取值范围作为二分搜索的搜索区间，初始化 `left` 和 `right` 变量
珂珂吃香蕉的速度最小是多少？多大是多少？
显然，最小速度应该是 `1`，最大速度是 `piles` 数组中元素的最大值，因为每小时最多吃一堆香蕉，胃口再大也白搭嘛。
这里可以有两种选择，要么你用一个 `for` 循环去遍历 `piles` 数组，计算最大值，要么你看题目给的约束，`piles` 中的元素取值范围是多少，然后给 `right` 初始化一个取值范围之外的值。
我选择第二种，题目说了 `1 <= piles[i] <= 10^9`，那么我就可以确定二分搜索的区间边界：

```c
public int minEatingSpeed(int[] piles, int H) {
    int left = 1;
    // 注意，right 是开区间，所以再加一
    int right = 1000000000 + 1;

    // ...
}
```

3. 根据题目的要求，确定应该使用搜索左侧还是搜索右侧的二分搜索算法，写出解法代码。

现在我们确定了自变量 `x `是吃香蕉的速度，`f(x)` 是单调递减的函数，`target` 就是吃香蕉的时间限制 `H`，题目要我们计算最小速度，也就是 `x` 要尽可能小：

![image.png](https://note.youdao.com/yws/res/11218/WEBRESOURCE3853747ff0c9a55a16251d31b54be8f6)

这就是搜索左侧边界的二分搜索嘛，不过注意 f(x) 是单调递减的，不要闭眼睛套框架，需要结合上图进行思考，写出代码：

注意 是`f(piles,mid)<=H` 还是`>= H`，就看函数单调性，因为要`right`向左靠，所以由图像可知，此时`f(x)`是小于`H`的，所以是前者。

```c
public int minEatingSpeed(int[] piles, int H) {
    int left = 1;
    int right = 1000000000 + 1;

    while (left < right) {
        int mid = left + (right - left) / 2;
        if (f(piles, mid) <= H) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}

// f(x) 随着 x 的增加单调递减
int f(int[] piles, int x) {
    // 见上文
}
```

> ！例题！关注

![image.png](https://note.youdao.com/yws/res/11231/WEBRESOURCE7f9b5096a7e1d704f9b6474b9d46e9f5)

简单说，给你输入一个数组 `nums` 和数字 `m`，你要把 `nums` 分割成 `m` 个子数组。

肯定有不止一种分割方法，每种分割方法都会把 `nums` 分成 `m` 个子数组，这 `m` 个子数组中肯定有一个和最大的子数组。

我们想要找一个分割方法，该方法分割出的最大子数组和是所有方法中最大子数组和最小的。

算法返回这个分割方法对应的最大子数组和。

怎么转化成二分搜索呢？

其实，这道题和上面讲的运输问题是一模一样的，你只有一艘货船，现在有若干货物，每个货物的重量是 `nums[i]`，现在你需要在 `m` 天内将这些货物运走，请问你的货船的最小载重是多少？

这不就是刚才我们解决的力扣第 1011 题「在 D 天内送达包裹的能力」吗？

货船每天运走的货物就是 `nums` 的一个子数组；在 `m` 天内运完就是将 `nums` 划分成 `m` 个子数组；让货船的载重尽可能小，就是让所有子数组中最大的那个子数组元素之和尽可能小。

```c
class Solution {
public:
int gx(vector<int>& nums, int k) {
    int count = 0;
    for(int i = 0; i < nums.size();) {
        int sum = k;
        while (i<nums.size())
        {
            if (nums[i] <= sum) {
                sum -= nums[i];}
            else break;
            i++;
        }
        count++;
    }
    return count;
}

int splitArray(vector<int>& nums, int m) {
    int left = 0;
    int right = 1;
    for (int w : nums) {
        left = std::max(left, w);
        right += w;
    }

    while (left < right)
    {
        int mid = left + (right - left) / 2;
        if (gx(nums, mid) <= m)right = mid;
        else left = mid + 1;
    }
    return left;
    
}

};
```

#### **自我总结**

- 1. **判断是不是用这个方法**

已知条件是随着要求的条件单调变换的
要求为已知条件 == constexpr

- 2. **写成f(x)的形式**

要求的条件为 x,已知的条件为f(x)

则此时的f(x)函数代码如何写？
输入值为已知的条件，！固定不变！，找出相应的f(x)的值作为返回的条件

！注意！此时一定不要搞混f(x)和调用函数
f(x)的输入是要求的条件x,输出是已知的条件f(x)
相当于固定了变量（要求的）

很多时候减法比加法常用
比如给定一个数组`nums`，给定一个常数`k`，分区间，区间的和不能超过这个常数,此时用减法就很简单
```
if(int i=0;i<nums.size();){
    while(i<nums.size(){
        if(sum < nums[i]) break;
        else  sum -= nums[i];
        i++;
    }
}
```
注意：if条件里面不能等于，因为可以放的下 -> i++，进入下一个循环，不能下一个，break；等于的情况是刚好放得下，属于第一种情况


- 3. **求最值**

那么此时要求的条件如何求最值呢？

找到左右边界，即x可取的最大最小值范围，注意此时right要+1,因为左闭右开。

取mid时相等的情况，是大于等于还是小于等于？看函数是递增还是递减的，如果是递减的，此时right取得的f（x）应该小于constexpr，所以是小于号，故`f(nums,mid)<=k;right = mid；`

### 前缀和数组

#### 适用情况

前缀和技巧适用于快速、频繁地计算一个索引区间内的元素之和

#### 实例

- 一维数组

![image.png](https://note.youdao.com/yws/res/11311/WEBRESOURCE95600f5b9915b0ce6e7d54ece7b3513f)

题目要求你实现这样一个类：
```c
class NumArray {

    public NumArray(int[] nums) {}

    /* 查询闭区间 [left, right] 的累加和 */
    public int sumRange(int left, int right) {}
}
```

`sumRange` 函数需要计算并返回一个索引区间之内的元素和。
如果用下面方法计算：

```c
class NumArray {

    private int[] nums;

    public NumArray(int[] nums) {
        this.nums = nums;
    }

    public int sumRange(int left, int right) {
        int res = 0;
        for (int i = left; i <= right; i++) {
            res += nums[i];
        }
        return res;
    }
}
```
可以达到效果，但是效率很差，因为 `sumRange` 方法会被频繁调用，而它的时间复杂度是 `O(N)`，其中 `N` 代表 `nums` 数组的长度。

这道题的最优解法是使用前缀和技巧，将 `sumRange` 函数的时间复杂度降为 `O(1)`,即不用在`sumRange` 里面用` for` 循环。

```c
class NumArray {
    // 前缀和数组
    private int[] preSum;

    /* 输入一个数组，构造前缀和 */
    public NumArray(int[] nums) {
        // preSum[0] = 0，便于计算累加和
        preSum = new int[nums.length + 1];
        // 计算 nums 的累加和
        for (int i = 1; i < preSum.length; i++) {
            preSum[i] = preSum[i - 1] + nums[i - 1];
        }
    }

    /* 查询闭区间 [left, right] 的累加和 */
    public int sumRange(int left, int right) {
        return preSum[right + 1] - preSum[left];
    }
}
```

核心思路是我们 `new` 一个新的数组 `preSum` 出来，`preSum[i]` 记录 `nums[0..i-1]` 的累加和。

![image.png](https://note.youdao.com/yws/res/11327/WEBRESOURCE49f2a5c6864d326d53d0842b410e2dd9)

这样，`sumRange` 函数仅仅需要做一次减法运算，避免了每次进行 `for` 循环调用，最坏时间复杂度为常数 `O(1)`。

- 二维数组

![image.png](https://note.youdao.com/yws/res/11358/WEBRESOURCEc7ff3cb30aa4aa884e10346516b3d2cc)

注意任意子矩阵的元素和可以转化成它周边几个大矩阵的元素和的运算：

![image.png](https://note.youdao.com/yws/res/11361/WEBRESOURCE64eafa5ee4ecae65326d3c27a601f7d4)

而这四个大矩阵有一个共同的特点，就是左上角都是 `(0, 0)` 原点。

我们可以维护一个二维 preSum 数组，专门记录以原点为顶点的矩阵的元素之和，就可以用几次加减运算算出任何一个子矩阵的元素和：

```c
class NumMatrix {
    // 定义：preSum[i][j] 记录 matrix 中子矩阵 [0, 0, i-1, j-1] 的元素和
    private int[][] preSum;

    public NumMatrix(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        if (m == 0 || n == 0) return;
        // 构造前缀和矩阵
        preSum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // 计算每个矩阵 [0, 0, i, j] 的元素和
                preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + matrix[i - 1][j - 1] - preSum[i-1][j-1];
            }
        }
    }

    // 计算子矩阵 [x1, y1, x2, y2] 的元素和
    public int sumRegion(int x1, int y1, int x2, int y2) {
        // 目标矩阵之和由四个相邻矩阵运算获得
        return preSum[x2+1][y2+1] - preSum[x1][y2+1] - preSum[x2+1][y1] + preSum[x1][y1];
    }
}
```

#### 模板

- 一维

实现一个 API，输入任意一个分数段，返回有多少同学的成绩在100这个分数段内：

```c
int[] scores; // 存储着所有同学的分数
// 试卷满分 100 分
int[] count = new int[100 + 1]
// 记录每个分数有几个同学
for (int score : scores)
    count[score]++
// 构造前缀和
for (int i = 1; i < count.length; i++)
    count[i] = count[i] + count[i-1];

// 利用 count 这个前缀和数组进行分数段查询
```

- 二维

计算子矩阵的元素和：
```c
class NumMatrix {
    // 定义：preSum[i][j] 记录 matrix 中子矩阵 [0, 0, i-1, j-1] 的元素和
    private int[][] preSum;

    public NumMatrix(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        if (m == 0 || n == 0) return;
        // 构造前缀和矩阵
        preSum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // 计算每个矩阵 [0, 0, i, j] 的元素和
                preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + matrix[i - 1][j - 1] - preSum[i-1][j-1];
            }
        }
    }

    // 计算子矩阵 [x1, y1, x2, y2] 的元素和
    public int sumRegion(int x1, int y1, int x2, int y2) {
        // 目标矩阵之和由四个相邻矩阵运算获得
        return preSum[x2+1][y2+1] - preSum[x1][y2+1] - preSum[x2+1][y1] + preSum[x1][y1];
    }
}
```


#### **自我总结**

场景：**前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和**。

- 一维

如果需要频繁计算一个区间内的和，则可以创建一个数组，把该数组进行如下处理：`prenums = new int[nums.size()+1]`,`nums[0] = 0`。数组元素存该索引前（包括该索引）的sum。当要求区间的和时，只需要调用`pernums[right+1] - pernums[left];`

- 二维

如果需要计算一个子矩阵的和，则可以创建一个矩阵，把该矩阵进行如下处理：

```c
int i = matrix.size();
int j = matrix[0].size();
preMatrix.resize(i + 1, vector<int>(j + 1));
//此时默认使preMatrix[0][j]==0 和 preMatrix[i][0]==0
```

矩阵索引应该存 从（0,0）- （i,j）包围的和

可按照如下进行循环迭代
![image.png](https://note.youdao.com/yws/res/11361/WEBRESOURCE64eafa5ee4ecae65326d3c27a601f7d4)

根据矩阵索引反求出子矩阵的和

注意问题，-1和不-1的问题，此算法没包括该点的值，所以计算（i2,j2）时需加1，计算（i1,j1）时则不需要。


### 前缀和、哈希表解法

题目：

> 连续数组525：给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。

分析：要找最长的连续数组，肯定有一个判断`res = max(res,len)`

如何找呢？求一个数组的子数组，满足对应的条件，想到前缀和，但是前缀和子数组是满足和等于一个值的，所以考虑将`0`设置为`-1`，`j`前缀和减去`i`前缀和等于`0`，则说明满足条件，即哈希表`key`值相等

```c
int findMaxLength(vector<int>& nums) {
    int n = nums.size();
    vector<int> preSum(n + 1);
    preSum[0] = 0;
    // 计算 nums 的前缀和
    for (int i = 0; i < n; i++) {
        preSum[i + 1] = preSum[i] + (nums[i] == 0 ? -1 : 1);
    }
    // 前缀和到索引的映射，方便快速查找所需的前缀和
    unordered_map<int, int> valToIndex;
    int res = 0;
    for (int i = 0; i < preSum.size(); i++) {
        // 如果这个前缀和还没有对应的索引，说明这个前缀和第一次出现，记录下来
        if (valToIndex.find(preSum[i]) == valToIndex.end()) {
            valToIndex[preSum[i]] = i;
        }
        else {
            // 这个前缀和已经出现过了，则找到一个和为 0 的子数组
            res = max(res, i - valToIndex[preSum[i]]);
        }
        // 因为题目想找长度最大的子数组，所以前缀和索引应尽可能小
    }
    return res;
}
```

为何只纪录第一个出现的，因为要求最长子数组长度，肯定是确定第一个，找最后一个在哪。

> 523. 连续的子数组和

给你一个整数数组 `nums` 和一个整数 `k`，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：子数组大小 至少为 `2`，且子数组元素总和为 `k `的倍数。如果存在，返回 `true`；否则，返回 `false`。

如果存在一个整数` n`，令整数 `x `符合 `x = n * k`，则称 `x` 是 `k` 的一个倍数。0 始终视为` k` 的一个倍数。

示例 1：
```c

输入：nums = [23,2,4,6,7], k = 6
输出：true
解释：[2,4] 是一个大小为 2 的子数组，并且和为 6。
```


寻找 `i`, `j` 使得` (preSum[i] - preSum[j]) % k == 0 且 i - j >= 2`。

另外，`(preSum[i] - preSum[j]) % k == 0 `其实就是 `preSum[i] % k == preSum[j] % k`。

所以我们使用一个哈希表，记录` preSum[j] % k` 的值以及对应的索引，就可以迅速判断 `preSum[i]` 是否符合条件了。

```c
class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        int n = nums.length;
        // 计算 nums 的前缀和
        int[] preSum = new int[n + 1];
        preSum[0] = 0;
        for (int i = 1; i <= n; i++) {
            preSum[i] = preSum[i - 1] + nums[i - 1];
        }
        // 前缀和与 k 的余数到索引的映射，方便快速查找所需的前缀和
        HashMap<Integer, Integer> valToIndex = new HashMap<>();
        for (int i = 0; i < preSum.length; i++) {
            // 在哈希表中记录余数
            int val = preSum[i] % k;
            // 如果这个余数还没有对应的索引，则记录下来
            if (!valToIndex.containsKey(val)) {
                valToIndex.put(val, i);
            }
            // 如果这个前缀和已经有对应的索引了，则什么都不做
            // 因为题目想找长度最大的子数组，所以前缀和索引应尽可能小
        }
        int res = 0;
        for (int i = 1; i < preSum.length; i++) {
            // 计算 need，使得 (preSum[i] - need) % k == 0
            int need = preSum[i] % k;
            if (valToIndex.containsKey(need)) {
                if (i - valToIndex.get(need) >= 2) {
                    // 这个子数组的长度至少为 2
                    return true;
                }
            }
        }
        return false;
    }
}
```


> 560. 和为 K 的子数组

给你一个整数数组 nums 和一个整数 k，请你统计并返回该数组中和为 k 的子数组的个数。

示例 1：

```c
输入：nums = [1,1,1], k = 2
输出：2
```

这道题依然考察 前缀和技巧 和哈希表的结合使用，请你先解决 523. 连续的子数组和 和 525. 连续数组，然后这道题就很容易解决了。

本题和前两题的最大区别在于，需要在维护 preSum 前缀和数组的同时动态维护 count 映射，而不能等到 preSum 计算完成后再处理 count，因为 count[need] 应该维护 preSum[0..i] 中值为 need 的元素个数。



```c
class Solution {
    public int subarraySum(int[] nums, int k) {
        int n = nums.length;
        // 前缀和数组
        int[] preSum = new int[n + 1];
        preSum[0] = 0;
        // 前缀和到该前缀和出现次数的映射，方便快速查找所需的前缀和
        HashMap<Integer, Integer> count = new HashMap<>();
        count.put(0, 1);
        // 记录和为 k 的子数组个数
        int res = 0;

        // 计算 nums 的前缀和
        for (int i = 1; i <= n; i++) {
            preSum[i] = preSum[i - 1] + nums[i - 1];
            // 如果之前存在值为 need 的前缀和
            // 说明存在以 nums[i-1] 结尾的子数组的和为 k
            int need = preSum[i] - k;
            if (count.containsKey(need)) {
                res += count.get(need);
            }
            // 将当前前缀和存入哈希表
            if (!count.containsKey(preSum[i])) {
                count.put(preSum[i], 1);
            } else {
                count.put(preSum[i], count.get(preSum[i]) + 1);
            }
        }
        return res;
    }
}
```


> 325. 和等于 k 的最长子数组长度

给定一个数组 nums 和一个目标值 k，找到和等于 k的最长连续子数组长度。如果不存在任意一个符合要求的子数组，则返回 0。

示例 1:

```c
输入：nums = [1,-1,5,-2,3], k = 3
输出：4 
解释：子数组 [1, -1, 5, -2] 和等于 3，且长度最长。
```



寻找 i, j 使得 preSum[i] - preSum[j] == k 且 i - j 尽可能的大。

另外，preSum[i] - preSum[j] == k 其实就是 preSum[j] == preSum[i] - k。

所以我们使用一个哈希表，记录 preSum[i] 的值以及这个前缀和第一次出现的索引，就可以迅速判断 preSum[i] 是否符合条件并计算最长子数组长度了.


```c
class Solution {
    public static int maxSubArrayLen(int[] nums, int k) {
        int n = nums.length;
        // preSum 中的值 -> 对应的最小索引
        // 比如 preSum = [2,4,1,3,4]，preSumToIndex[4] = 1
        HashMap<Integer, Integer> preSumToIndex = new HashMap<>();
        int maxLen = 0;
        // 前缀和数组（在这道题中可以优化为一个变量）
        int preSum = 0;
        // base case，这样索引相减的时候可以算出正确的子数组长度
        preSumToIndex.put(0, -1);
        for (int i = 0; i < n; i++) {
            // 计算前缀和，维护 preSum = sum(nums[0..i])
            preSum += nums[i];
            // 确保 preSumToIndex 中记录的索引是第一次出现的位置
            preSumToIndex.putIfAbsent(preSum, i);
            int need = preSum[i] - k;
            if (preSumToIndex.containsKey(need)) {
                int j = preSumToIndex.get(need);
                // nums[j..i] 是和为 k 的子数组
                maxLen = Math.max(maxLen, i - j);
            }
        }
        return maxLen;
    }
}
```

> 974. 和可被 K 整除的子数组

给定一个整数数组 nums 和一个整数 k，返回其中元素之和可被 k 整除的（连续非空）子数组 的数目。

示例 1：

```c
输入：nums = [4,5,0,-2,-3,1], k = 5
输出：7
解释：
有 7 个子数组满足其元素之和可被 k = 5 整除：
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]
```

```c
class Solution {
    public int subarraysDivByK(int[] nums, int k) {
        int n = nums.length;
        // nums 的前缀和数组，注意索引偏移，preSum[i] 的值为 sum(nums[0..i-1])
        int[] preSum = new int[n + 1];
        // 前缀和余数的计数器，方便快速查找所需的前缀和余数的数量
        HashMap<Integer, Integer> remainderToCount = new HashMap<>();
        preSum[0] = 0;
        remainderToCount.put(0, 1);
        // 计算 nums 的前缀和余数并更新计数器
        int res = 0;
        for (int i = 0; i < n; i++) {
            // 计算 nums[0..i] 的前缀和
            preSum[i + 1] = preSum[i] + nums[i];
            // nums[0..i] 的所有元素之和与 k 的余数
            int curRemainder = preSum[i + 1] % k;
            if (curRemainder < 0) {
                // Java 求模的特性，-2 % 3 = -2，但我们实际想要正余数 1
                curRemainder += k;
            }
            // 看看之前 nums[0..i-1] 中是否也存在前缀和余数为 curRemainder 的子数组
            if (remainderToCount.containsKey(curRemainder)) {
                // 如果存在，则说明找到了可以整除 k 的子数组，累加子数组数量
                int count = remainderToCount.get(curRemainder);
                res += count;
                remainderToCount.put(curRemainder, count + 1);
            } else {
                // 如果不存在，那么 nums[0..i] 是第一个前缀和余数为 curRemainder 的子数组
                remainderToCount.put(curRemainder, 1);
            }
        }
        return res;
    }
}
```

需要注意算余数的时候，要正余数，需要+k


> 1124. 表现良好的最长时间段

给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「劳累的一天」。所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格大于「不劳累的天数」。请你返回「表现良好时间段」的最大长度。

示例 1：

```c
输入：hours = [9,9,6,0,6,6,9]
输出：3
解释：最长的表现良好时间段是 [9,9,6]。
```


题目说 hours[i] 以 8 作为分界线，那么我们就要条件反射地想到对数据进行「归一化」处理，比如把所有大于 8 的元素视为 +1，把所有小于 8 的元素视为 -1，这样一来，这道题就改造成了：计算数组中元素和大于 0 的子数组的最大长度。

我们借助哈希表存储前缀和到索引的映射，这样就能快速寻找一个 j 使得 preSum[i] - preSum[j] > 0


```c
class Solution {
    public int longestWPI(int[] hours) {
        int n = hours.length;
        int[] preSum = new int[n + 1];
        preSum[0] = 0;
        // 前缀和到索引的映射，方便快速查找所需的前缀和
        HashMap<Integer, Integer> valToIndex = new HashMap<>();
        int res = 0;
        for (int i = 1; i <= n; i++) {
            // 计算 nums[0..i-1] 的前缀和
            preSum[i] = preSum[i - 1] + (hours[i - 1] > 8 ? 1 : -1);
            // 如果这个前缀和还没有对应的索引，说明这个前缀和第一次出现，记录下来
            if (!valToIndex.containsKey(preSum[i])) {
                valToIndex.put(preSum[i], i);
            } else {
                // 因为题目想找长度最大的子数组，valToIndex 中的索引应尽可能小，
                // 所以这里什么都不做
            }

            // 现在我们想找 hours[0..i-1] 中元素和大于 0 的子数组
            // 这就要根据 preSum[i] 的正负分情况讨论了
            if (preSum[i] > 0) {
                // preSum[i] 为正，说明 hours[0..i-1] 都是「表现良好的时间段」
                res = Math.max(res, i);
            } else {
                // preSum[i] 为负，需要寻找一个 j 使得 preSum[i] - preSum[j] > 0
                // 且 j 应该尽可能小，即寻找 preSum[j] == preSum[i] - 1
                if (valToIndex.containsKey(preSum[i] - 1)) {
                    int j = valToIndex.get(preSum[i] - 1);
                    res = Math.max(res, i - j);
                }
            }
        }
        return res;
    }
}
```

注意点在找大于0这块

#### 自我总结

使用场景：求一个数组的子数组和满足某些条件

使用前缀和和哈希表结合，将前缀和当成哈希表的`key`值
前缀和不论加不加首个元素，长度都是`j-i`

> 关于哈希表前缀和`key`值

有两个方法，第一种先遍历循环，再带入`key`值

```c
vector<int>preSum(nums.size()+1);
preSum[0] = 0;
for (int i = 1; i <= n; i++) {
   preSum[i] = preSum[i - 1] + nums[i - 1];
}

//与哈希表映射

for (int i = 0; i < preSum.length; i++) {

}

```

第二种直接在映射中带入

```c
valToIndex[0] =-1;//前面添加一个元素，考虑到从0-i的情况,长度
valToCount[0] = 1;//出现次数
for (int i = 0; i < n; i++) {
    preSum += nums[i];
}
```

- 情况1：求最长数组

既然要求最长数组，那么前缀和索引要尽可能的小，所以如果遍历到后面，发现前面有相同的`key`值，那么该值不能被存储

```c
// 如果这个前缀和还没有对应的索引，说明这个前缀和第一次出现，记录下来
// 因为题目想找长度最大的子数组，所以前缀和索引应尽可能小
 
if(!valToIndex.count(preSum[i])){
    valToIndex[preSum[i]] = i;
}
else{
    .........
}
```

- 情况2：出现个数

既然只需要出现的个数，那么`key`:前缀和，`value`:出现次数

```c
valToIndex[0] =-1;//前面添加一个元素，考虑到从0-i的情况
 for (int i = 0; i < n; i++) {
    preSum += nums[i];
    // 如果之前存在值为 need 的前缀和
    // 说明存在以 nums[i-1] 结尾的子数组的和为 k
    int need = preSum - k;
    if (valToIndex.count(need)) {
        res += valToIndex[need];
    }
    // 将当前前缀和存入哈希表
    if (!valToIndex.count(preSum)) {
        valToIndex.[preSum] = 1;
    } else {
        valToIndex.[preSum] += 1;
    }
}
```

- 满足条件情况

1. 和为0，即两位置前缀和相等

```c
//判断该`key`值是否存在即可
valToIndex[0] =-1;//前面添加一个元素，考虑到从0-i的情况

for(int i=0;i<n;i++){
    preSum += nums[i];
    .......
    if(valToIndex.count(preSum)){
        len = max(len,i-valToIndex[preSum]);
    }
}
```

2. 和为K

```c
valToIndex[0] =-1;//前面添加一个元素，考虑到从0-i的情况
 for (int i = 0; i < n; i++) {
    // 计算前缀和，维护 preSum = sum(nums[0..i])
    preSum += nums[i];
    // 确保 preSumToIndex 中记录的索引是第一次出现的位置
    if(!valToIndex.count(preSum[i])){
    valToIndex[preSum[i]] = i;
    }
    int need = preSum[i] - k;
    if (preSumToIndex.count(need)) {
        int j = preSumToIndex[need];
        // nums[j..i] 是和为 k 的子数组
        maxLen = Math.max(maxLen, i - j);
    }
}
```

3. 和为K的倍数

寻找 `i`, `j` 使得 `(preSum[i] - preSum[j]) % k == 0 `且 `i - j >= 2`。
`(preSum[i] - preSum[j]) % k == 0` 其实就是 `preSum[i] % k == preSum[j] % k`。

```c
// 求最长
valToIndex[0] =-1;//前面添加一个元素，考虑到从0-i的情况
 for (int i = 0; i < nums.size(); i++) {
    presum += nums[i];
    if (idex.count(presum % k)) {
        ........
    }
    else {
        idex[presum % k] = i;
    }
}
```
4. 和大于某个数

例如 子数组大于8的数要多余小于等于8的数

可以将大于8的都设置为1，小于等于8的都设置为-1，那么和大于0。

```c
for (int i = 1; i <= n; i++) {
    // 计算 nums[0..i-1] 的前缀和
    preSum[i] = preSum[i - 1] + (hours[i - 1] > 8 ? 1 : -1);
    // 如果这个前缀和还没有对应的索引，说明这个前缀和第一次出现，记录下来
    if (!valToIndex.containsKey(preSum[i])) {
        valToIndex.put(preSum[i], i);
    } else {
        // 因为题目想找长度最大的子数组，valToIndex 中的索引应尽可能小，
        // 所以这里什么都不做
    }

    // 现在我们想找 hours[0..i-1] 中元素和大于 0 的子数组
    // 这就要根据 preSum[i] 的正负分情况讨论了
    if (preSum[i] > 0) {
        // preSum[i] 为正，说明 hours[0..i-1] 都是「表现良好的时间段」
        res = Math.max(res, i);
    } else {
        // preSum[i] 为负，需要寻找一个 j 使得 preSum[i] - preSum[j] > 0
        // 且 j 应该尽可能小，即寻找 preSum[j] == preSum[i] - 1
        if (valToIndex.containsKey(preSum[i] - 1)) {
            int j = valToIndex.get(preSum[i] - 1);
            res = Math.max(res, i - j);
        }
    }
}
    return res;
```

### 差分数组

#### 适用场景

**差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减**。

比如说，我给你输入一个数组 `nums`，然后又要求给区间 `nums[2..6]` 全部加 `1`，再给 `nums[3..9]` 全部减 `3`，再给 `nums[0..4]` 全部加 `2`，再给…，然后问你，最后 `nums` 数组的值是什么？

需要差分数组的技巧，类似前缀和技巧构造的 `prefix` 数组，我们先对 `nums` 数组构造一个 `diff` 差分数组，`diff[i]` 就是 `nums[i]` 和 `nums[i-1]` 之差：

```c
int[] diff = new int[nums.length];
// 构造差分数组
diff[0] = nums[0];
for (int i = 1; i < nums.length; i++) {
    diff[i] = nums[i] - nums[i - 1];
}
```

![image.png](https://note.youdao.com/yws/res/11393/WEBRESOURCEc4c25f1d0dffde0653a8b723bdd0d329)

通过这个 `diff` 差分数组是可以反推出原始数组` nums` 的，代码逻辑如下：

```c
int[] res = new int[diff.length];
// 根据差分数组构造结果数组
res[0] = diff[0];
for (int i = 1; i < diff.length; i++) {
    res[i] = res[i - 1] + diff[i];
}
```

这样构造差分数组` diff`，就可以快速进行区间增减的操作，如果你想对区间` nums[i..j]` 的元素全部加 `3`，那么只需要让 `diff[i] += 3`，然后再让 `diff[j+1] -= 3` 即可:

![image.png](https://note.youdao.com/yws/res/11398/WEBRESOURCE6317dc476c785579ffa28ef72b7e29c7)

原理很简单，回想` diff` 数组反推 `nums` 数组的过程`，diff[i] += 3` 意味着给 `nums[i..]` 所有的元素都加了` 3`，然后 `diff[j+1] -= 3 `又意味着对于 `nums[j+1..]` 所有元素再减 `3`，那综合起来，是不是就是对 `nums[i..j]` 中的所有元素都加`3` 了

具体实现：

```c
// 差分数组工具类
class Difference {
    // 差分数组
    private int[] diff;

    /* 输入一个初始数组，区间操作将在这个数组上进行 */
    public Difference(int[] nums) {
        assert nums.length > 0;
        diff = new int[nums.length];
        // 根据初始数组构造差分数组
        diff[0] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            diff[i] = nums[i] - nums[i - 1];
        }
    }

    /* 给闭区间 [i, j] 增加 val（可以是负数）*/
    public void increment(int i, int j, int val) {
        diff[i] += val;
        if (j + 1 < diff.length) {
            diff[j + 1] -= val;
        }
    }

    /* 返回结果数组 */
    public int[] result() {
        int[] res = new int[diff.length];
        // 根据差分数组构造结果数组
        res[0] = diff[0];
        for (int i = 1; i < diff.length; i++) {
            res[i] = res[i - 1] + diff[i];
        }
        return res;
    }
}
```

#### **自我总结**

场景：适用于频繁对原始数组的某个区间的元素进行增减

>  具体步骤

- diff数组的创建操作

```c
 public Difference(int[] nums) {
        assert nums.length > 0;
        diff = new int[nums.length];
        // 根据初始数组构造差分数组
        diff[0] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            diff[i] = nums[i] - nums[i - 1];
        }
    }
```

注意：
此时`diff`数组的长度和`nums`数组的长度相同，而不是和前缀和一样 `+1`，所以该点的索引就等于该点元素减去前面点元素，而不是和前缀和一样，该点为该点之前的元素和，不包括该点元素

- increment增减操作

```c
/* 给闭区间 [i, j] 增加 val（可以是负数）*/
public void increment(int i, int j, int val) {
        diff[i] += val;
        if (j + 1 < diff.length) {
            diff[j + 1] -= val;
        }
    }
```

注意：
此时if判断条件，因为如果到了最后一个元素，后面就没元素了，所以不需要 `-=val`。

- result输出结果数组操作

```c
public int[] result() {
    int[] res = new int[diff.length];
    // 根据差分数组构造结果数组
    res[0] = diff[0];
    for (int i = 1; i < diff.length; i++) {
        res[i] = res[i - 1] + diff[i];
    }
    return res;
  }
```

注意：
`for`循环里面的逻辑， 当前索引的元素 等于 该点前索引的元素 加上 该点的差分数组的元素

！**注意**！
差分数组 -> `diff`  索引数组 -> `res` 。不是nums数组！因为此时的`diff`数组表示的是 当前构造的数组 的 差分数组，第一步得出的差分数组才是`nums`的差分数组

### 前缀积数组

![image.png](https://note.youdao.com/yws/res/11576/WEBRESOURCEd892e53d6dcdb2efc394b7e287c49d66)

这道题和 `前缀和数组技巧` 有些类似，构造一个 `prefix` 数组记录「前缀积」,但是题目不能用除法,索引数组后面元素的乘积怎么计算？

！**通过构造后缀积的方式**！

再用一个 `suffix` 记录「后缀积」，根据前缀和后缀积就能计算除了当前元素之外其他元素的积

```c
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        // 从左到右的前缀积，prefix[i] 是 nums[0..i] 的元素积
        int[] prefix = new int[n];
        prefix[0] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            prefix[i] = prefix[i - 1] * nums[i];
        }
        // 从右到左的前缀积，suffix[i] 是 nums[i..n-1] 的元素积
        int[] suffix = new int[n];
        suffix[n - 1] = nums[n - 1];
        for (int i = n - 2; i >= 0; i--) {
            suffix[i] = suffix[i + 1] * nums[i];
        }
        // 结果数组
        int[] res = new int[n];
        res[0] = suffix[1];
        res[n - 1] = prefix[n - 2];
        for (int i = 1; i < n - 1; i++) {
            // 除了 nums[i] 自己的元素积就是 nums[i] 左侧和右侧所有元素之积
            res[i] = prefix[i - 1] * suffix[i + 1];
        }
        return res;
    }
}
```

#### **自我总结**

前缀积和前缀和方法差不多，但是需要注意的是
前缀和：一个区间的和 可以通过后面➖前面方式
前缀积：经常和后缀积搭配使用

## 多数之和

-  `twoSum `问题

如果假设输入一个数组 `nums` 和一个目标和 `target`，请你返回` nums` 中能够凑出 `target` 的两个元素的值，比如输入 `nums = [1,3,5,6]`, `target = 9`，那么算法返回两个元素` [3,6]`。可以假设只有且仅有一对儿元素可以凑出 `target`。

```c
vector<int> twoSum(vector<int>& nums, int target) {
    // 先对数组排序
    sort(nums.begin(), nums.end());
    // 左右指针
    int lo = 0, hi = nums.size() - 1;
    while (lo < hi) {
        int sum = nums[lo] + nums[hi];
        // 根据 sum 和 target 的比较，移动左右指针
        if (sum < target) {
            lo++;
        } else if (sum > target) {
            hi--;
        } else if (sum == target) {
            return {nums[lo], nums[hi]};
        }
    }
    return {};
}
```


把这个题目变得更泛化:

`nums `中可能有多对儿元素之和都等于 `target`，请你的算法返回所有和为` target` 的元素对儿，其中不能出现重复。

函数签名如下：

```c
vector<vector<int>> twoSumTarget(vector<int>& nums, int target);
```

基本思路肯定还是排序加双指针：

```c
vector<vector<int>> twoSumTarget(vector<int>& nums, int target) {
    // 先对数组排序
    sort(nums.begin(), nums.end());
    vector<vector<int>> res;
    int lo = 0, hi = nums.size() - 1;
    while (lo < hi) {
        int sum = nums[lo] + nums[hi];
        // 根据 sum 和 target 的比较，移动左右指针
        if      (sum < target) lo++;
        else if (sum > target) hi--;
        else {
            res.push_back({nums[lo], nums[hi]});
            lo++; hi--;
        }
    }
    return res;
}
```

但是，这样实现会造成重复的结果，比如说` nums = [1,1,1,2,2,3,3]`, `target = 4`，得到的结果中` [1,3]` 肯定会重复。

出问题的地方在于` sum == target `条件的 `if `分支，当给 `res` 加入一次结果后，`lo` 和` hi `不仅应该相向而行，而且应该跳过所有重复的元素：

![image.png](https://note.youdao.com/yws/res/11906/WEBRESOURCE065b3f51de74b1dc967bda9e3936caee)

可以对双指针的 while 循环做出如下修改：

```c
while (lo < hi) {
    int sum = nums[lo] + nums[hi];
    // 记录索引 lo 和 hi 最初对应的值
    int left = nums[lo], right = nums[hi];
    if (sum < target)      lo++;
    else if (sum > target) hi--;
    else {
        res.push_back({left, right});
        // 跳过所有重复的元素
        while (lo < hi && nums[lo] == left) lo++;
        while (lo < hi && nums[hi] == right) hi--;
    }
}
```


这样就可以保证一个答案只被添加一次，重复的结果都会被跳过，可以得到正确的答案。不过，受这个思路的启发，其实前两个 if 分支也是可以做一点效率优化，跳过相同的元素：

```c
vector<vector<int>> twoSumTarget(vector<int>& nums, int target) {
    // nums 数组必须有序
    sort(nums.begin(), nums.end());
    int lo = 0, hi = nums.size() - 1;
    vector<vector<int>> res;
    while (lo < hi) {
        int sum = nums[lo] + nums[hi];
        int left = nums[lo], right = nums[hi];
        if (sum < target) {
            while (lo < hi && nums[lo] == left) lo++;            
        } else if (sum > target) {
            while (lo < hi && nums[hi] == right) hi--;
        } else {
            res.push_back({left, right});
            while (lo < hi && nums[lo] == left) lo++;
            while (lo < hi && nums[hi] == right) hi--;
        }
    }
    return res;
}
```

- `3Sum `问题

![image.png](https://note.youdao.com/yws/res/11917/WEBRESOURCE25638c52bd072c551c0b070ee4900953)

函数签名如下：
```c
vector<vector<int>> threeSum(vector<int>& nums);
```

我们再泛化一下题目，不要光和为 0 的三元组了，计算和为 target 的三元组吧，同上面的 twoSum 一样，也不允许重复的结果：

```c
vector<vector<int>> threeSum(vector<int>& nums) {
    // 求和为 0 的三元组
    return threeSumTarget(nums, 0);
}

vector<vector<int>> threeSumTarget(vector<int>& nums, int target) {
    // 输入数组 nums，返回所有和为 target 的三元组
}
```


这个问题怎么解决呢？很简单，穷举呗。现在我们想找和为 `target` 的三个数字，那么对于第一个数字，可能是什么？nums 中的每一个元素` nums[i]` 都有可能！

那么，确定了第一个数字之后，剩下的两个数字可以是什么呢？其实就是和为` target - nums[i] `的两个数字呗，那不就是 `twoSum` 函数解决的问题么🤔

可以直接写代码了，需要把 `twoSum `函数稍作修改即可复用：

```c
/* 从 nums[start] 开始，计算有序数组
 * nums 中所有和为 target 的二元组 */
vector<vector<int>> twoSumTarget(
    vector<int>& nums, int start, int target) {
    // 左指针改为从 start 开始，其他不变
    int lo = start, hi = nums.size() - 1;
    vector<vector<int>> res;
    while (lo < hi) {
        ...
    }
    return res;
}

/* 计算数组 nums 中所有和为 target 的三元组 */
vector<vector<int>> threeSumTarget(vector<int>& nums, int target) {
    // 数组得排个序
    sort(nums.begin(), nums.end());
    int n = nums.size();
    vector<vector<int>> res;
    // 穷举 threeSum 的第一个数
    for (int i = 0; i < n; i++) {
        // 对 target - nums[i] 计算 twoSum
        vector<vector<int>> 
            tuples = twoSumTarget(nums, i + 1, target - nums[i]);
        // 如果存在满足条件的二元组，再加上 nums[i] 就是结果三元组
        for (vector<int>& tuple : tuples) {
            tuple.push_back(nums[i]);
            res.push_back(tuple);
        }
        // 跳过第一个数字重复的情况，否则会出现重复结果
        while (i < n - 1 && nums[i] == nums[i + 1]) i++;
    }
    return res;
}
```

- `4Sum` 问题

![image.png](https://note.youdao.com/yws/res/11928/WEBRESOURCEe8e4484587fbb094f05838daf0a3066a)

函数签名如下:
```c
vector<vector<int>> fourSum(vector<int>& nums, int target);
```

4Sum 完全就可以用相同的思路：穷举第一个数字，然后调用 3Sum 函数计算剩下三个数，最后组合出和为 target 的四元组。

```c
vector<vector<int>> fourSum(vector<int>& nums, int target) {
    // 数组需要排序
    sort(nums.begin(), nums.end());
    int n = nums.size();
    vector<vector<int>> res;
    // 穷举 fourSum 的第一个数
    for (int i = 0; i < n; i++) {
        // 对 target - nums[i] 计算 threeSum
        vector<vector<int>> 
            triples = threeSumTarget(nums, i + 1, target - nums[i]);
        // 如果存在满足条件的三元组，再加上 nums[i] 就是结果四元组
        for (vector<int>& triple : triples) {
            triple.push_back(nums[i]);
            res.push_back(triple);
        }
        // fourSum 的第一个数不能重复
        while (i < n - 1 && nums[i] == nums[i + 1]) i++;
    }
    return res;
}

/* 从 nums[start] 开始，计算有序数组
 * nums 中所有和为 target 的三元组 */
vector<vector<int>> threeSumTarget(vector<int>& nums, int start, long target) {
        int n = nums.size();
        vector<vector<int>> res;
        // i 从 start 开始穷举，其他都不变
        for (int i = start; i < n; i++) {
            ...
        }
        return res;
```

- `nSum` 问题


`nSum`函数：

```c
/* 注意：调用这个函数之前一定要先给 nums 排序 */
// n 填写想求的是几数之和，start 从哪个索引开始计算（一般填 0），target 填想凑出的目标和
vector<vector<int>> nSumTarget(
    vector<int>& nums, int n, int start, long target) {

    int sz = nums.size();
    vector<vector<int>> res;
    // 至少是 2Sum，且数组大小不应该小于 n
    if (n < 2 || sz < n) return res;
    // 2Sum 是 base case
    if (n == 2) {
        // 双指针那一套操作
        int lo = start, hi = sz - 1;
        while (lo < hi) {
            int sum = nums[lo] + nums[hi];
            int left = nums[lo], right = nums[hi];
            if (sum < target) {
                while (lo < hi && nums[lo] == left) lo++;
            } else if (sum > target) {
                while (lo < hi && nums[hi] == right) hi--;
            } else {
                res.push_back({left, right});
                while (lo < hi && nums[lo] == left) lo++;
                while (lo < hi && nums[hi] == right) hi--;
            }
        }
    } else {
        // n > 2 时，递归计算 (n-1)Sum 的结果
        for (int i = start; i < sz; i++) {
            vector<vector<int>> 
                sub = nSumTarget(nums, n - 1, i + 1, target - nums[i]);
            for (vector<int>& arr : sub) {
                // (n-1)Sum 加上 nums[i] 就是 nSum
                arr.push_back(nums[i]);
                res.push_back(arr);
            }
            while (i < sz - 1 && nums[i] == nums[i + 1]) i++;
        }
    }
    return res;
}
```

调用这个 `nSumTarget` 函数之前一定要先给 `nums` 数组排序，因为` nSumTarget` 是一个递归函数，如果在` nSumTarget` 函数里调用排序函数，那么每次递归都会进行没有必要的排序，效率会非常低。


> 注意：两数之和，求的不是值，是索引，可以用哈希表的方法来求解

![image.png](https://note.youdao.com/yws/res/11964/WEBRESOURCE51fe23054b0601ed81ba198609dd3d49)

```c
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> hashtable;
        for (int i = 0; i < nums.size(); ++i) {
            auto it = hashtable.find(target - nums[i]);
            if (it != hashtable.end()) {
                return {it->second, i};
            }
            hashtable[nums[i]] = i;
        }
        return {};
    }
};
```

思路，循环遍历`nums`中的元素作为开头，在哈希表中找另一个元素，其值为 `target - nums[i]`，哈希表中没找到，加入遍历的元素，找到，返回。在找的过程中也是更新哈希表的过程。


#### **自我总结**

如果是`2Sum`求和，先将数组排序，然后左右指针，逐渐向里缩，此时注意，如果要避免重复，则添加判断，如果下一个/上一个和当前相同，则跳过。

如果是`3Sum`求和，则选取一个数开始遍历这个数之后的数组，找到是否符合条件的

如果是`4Sum`求和，做法相似，进行递归即可

`nSum`模板：

```c
/* 注意：调用这个函数之前一定要先给 nums 排序 */
// n 填写想求的是几数之和，start 从哪个索引开始计算（一般填 0），target 填想凑出的目标和
vector<vector<int>> nSumTarget(
    vector<int>& nums, int n, int start, long target) {

    int sz = nums.size();
    vector<vector<int>> res;
    // 至少是 2Sum，且数组大小不应该小于 n
    if (n < 2 || sz < n) return res;
    // 2Sum 是 base case
    if (n == 2) {
        // 双指针那一套操作
        int lo = start, hi = sz - 1;
        while (lo < hi) {
            int sum = nums[lo] + nums[hi];
            int left = nums[lo], right = nums[hi];
            if (sum < target) {
                while (lo < hi && nums[lo] == left) lo++;
            } else if (sum > target) {
                while (lo < hi && nums[hi] == right) hi--;
            } else {
                res.push_back({left, right});
                while (lo < hi && nums[lo] == left) lo++;
                while (lo < hi && nums[hi] == right) hi--;
            }
        }
    } else {
        // n > 2 时，递归计算 (n-1)Sum 的结果
        for (int i = start; i < sz; i++) {
            vector<vector<int>> 
                sub = nSumTarget(nums, n - 1, i + 1, target - nums[i]);
            for (vector<int>& arr : sub) {
                // (n-1)Sum 加上 nums[i] 就是 nSum
                arr.push_back(nums[i]);
                res.push_back(arr);
            }
            while (i < sz - 1 && nums[i] == nums[i + 1]) i++;
        }
    }
    return res;
}
```

注意：

1. 递归终止条件不能少,` if (n < 2 || sz < n) return res;`
2. 分成两类，`n`大于`2`，调用降 `n` 并且递归，`n`等于`2`，左右指针找值。
3. `n`大于`2`的循环，`i`是从`start`开始的，因为是其中一个递归，所以不是从`0`开始。

## 反转数组

一般编程语言都会提供 reverse 函数，其实这个函数的原理非常简单，让你反转一个 char[] 类型的字符数组。

```c
void reverseString(char[] s) {
    // 一左一右两个指针相向而行
    int left = 0, right = s.length - 1;
    while (left < right) {
        // 交换 s[left] 和 s[right]
        char temp = s[left];
        s[left] = s[right];
        s[right] = temp;
        left++;
        right--;
    }
}
```

## 回文串判断

#### 场景：求回文串

回文串就是正着读和反着读都一样的字符串。

判断一个字符串是不是回文串，代码：

```c
boolean isPalindrome(String s) {
    // 一左一右两个指针相向而行
    int left = 0, right = s.length() - 1;
    while (left < right) {
        if (s.charAt(left) != s.charAt(right)) {
            return false;
        }
        left++;
        right--;
    }
    return true;
}
```


示例：
![image.png](https://note.youdao.com/yws/res/11845/WEBRESOURCE619867add3ad6ee92e7b09dde76e5699)


函数签名如下：

```c
String longestPalindrome(String s);
```

> 思路

回文串的的长度可能是奇数也可能是偶数，解决该问题的核心是从中心向两端扩散的双指针技巧。


如果回文串的长度为奇数，则它有一个中心字符；如果回文串的长度为偶数，则可以认为它有两个中心字符。所以我们可以先实现这样一个函数:


```c
string is_Palindrome(string t,int left,int right) {
	while (left >= 0 && right < t.size() && t[left] == t[right])
	{
		left--; right++;
	}

	return t.substr(left + 1, right - left - 1);
}
```

这样，如果输入相同的 `l` 和 `r`，就相当于寻找长度为奇数的回文串，如果输入相邻的 `l` 和 `r`，则相当于寻找长度为偶数的回文串。

那么回到最长回文串的问题，解法的大致思路就是：

```c
for 0 <= i < len(s):
    找到以 s[i] 为中心的回文串
    找到以 s[i] 和 s[i+1] 为中心的回文串
    更新答案
```

翻译成代码，就可以解决最长回文子串这个问题：

```c
String longestPalindrome(String s) {
    String res = "";
    for (int i = 0; i < s.length(); i++) {
        // 以 s[i] 为中心的最长回文子串
        String s1 = palindrome(s, i, i);
        // 以 s[i] 和 s[i+1] 为中心的最长回文子串
        String s2 = palindrome(s, i, i + 1);
        // res = longest(res, s1, s2)
        res = res.length() > s1.length() ? res : s1;
        res = res.length() > s2.length() ? res : s2;
    }
    return res;
}
```

#### **自我总结**

场景：回文串类型

最长回文子串使用的左右指针和之前题目的左右指针有一些不同：之前的左右指针都是从两端向中间相向而行，而回文子串问题则是让左右指针从中心向两端扩展。

> 方法

1. 先写一个函数`Palindrome`，该函数能返回一个字符串，该字符串是以`left`,`right`为中心向外扩散的回文串。

2. 循环给定的字符串`s`，以每个点为中心点来找相应的回文串，此时有：奇数回文串（`left`==`right`扩散）和偶数回文串(`left + 1`==`right`扩散)。相互比较，循环遍历，最终找到最长的回文串。

模板：

函数`Palindrome`：
```c
string is_Palindrome(string t,int left,int right) {
	while (left >= 0 && right < t.size() && t[left] == t[right])
	{
		left--; right++;
	}

	return t.substr(left + 1, right - left - 1);
}
```

`left`，`right`是中心点，当回文串的长度为为奇数时，此时 `left` == `right`，当回文串的长度为偶数时，此时`right` == `left` + 1;

求解函数：

```c
String longestPalindrome(String s) {
    String res = "";
    for (int i = 0; i < s.length(); i++) {
        // 以 s[i] 为中心的最长回文子串
        String s1 = palindrome(s, i, i);
        // 以 s[i] 和 s[i+1] 为中心的最长回文子串
        String s2 = palindrome(s, i, i + 1);
        // res = longest(res, s1, s2)
        res = res.length() > s1.length() ? res : s1;
        res = res.length() > s2.length() ? res : s2;
    }
    return res;
}
```

# 链表

链表技巧：

1. 合并两个有序链表

2. 链表的分解

3. 合并 k 个有序链表

4. 寻找单链表的倒数第 k 个节点

5. 寻找单链表的中点

6. 判断单链表是否包含环并找出环起点

7. 判断两个单链表是否相交并找出交点

### 合并两个有序链表

![image.png](https://note.youdao.com/yws/res/12125/WEBRESOURCE77fb7d9d7de4bcfae42b62a38e25fb65)

函数签名如下：

```c
ListNode mergeTwoLists(ListNode l1, ListNode l2);
```

```c
ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    // 虚拟头结点
    ListNode dummy = new ListNode(-1), p = dummy;
    ListNode p1 = l1, p2 = l2;

    while (p1 != null && p2 != null) {        



        // 比较 p1 和 p2 两个指针
        // 将值较小的的节点接到 p 指针
        if (p1.val > p2.val) {
            p.next = p2;
            p2 = p2.next;
        } else {
            p.next = p1;
            p1 = p1.next;
        }
        // p 指针不断前进
        p = p.next;
    }

    if (p1 != null) {
        p.next = p1;
    }

    if (p2 != null) {
        p.next = p2;
    }

    return dummy.next;
}
```

我们的 `while` 循环每次比较 `p1` 和 `p2` 的大小，把较小的节点接到结果链表上，看如下 GIF：

![](https://labuladong.github.io/algo/images/%E9%93%BE%E8%A1%A8%E6%8A%80%E5%B7%A7/1.gif)

**代码中还用到一个链表的算法题中是很常见的「虚拟头结点」技巧，也就是 dummy 节点。**

> **何时用虚拟头节点**

**当你需要创造一条新链表的时候，可以使用虚拟头结点简化边界情况的处理。**


注意： c++ 对链表的定义是指针，创建`dummy`指针的写法 `ListNode* dummy = new ListNode(0);`要特别注意

#### **自我总结**

创建一个新链表，分别循环两个已知链表，对比其大小，将符合条件的作为新链表的`next`，如此反复，将某个链表为`nullptr`时，停止循环，将另一个链表直接连接在新链表后面。

注意，创建新链表，由于边界情况，所以加**头结点**避免！

### 单链表的分解

![image.png](https://note.youdao.com/yws/res/12142/WEBRESOURCE8cd57d65ce4dd059d80b8c38f7b60136)

我们可以把原链表分成两个小链表，一个链表中的元素大小都小于 `x`，另一个链表中的元素都大于等于 `x`，最后再把这两条链表接到一起。

注意虚拟头结点的运用：

```c
ListNode partition(ListNode head, int x) {
    // 存放小于 x 的链表的虚拟头结点
    ListNode dummy1 = new ListNode(-1);
    // 存放大于等于 x 的链表的虚拟头结点
    ListNode dummy2 = new ListNode(-1);
    // p1, p2 指针负责生成结果链表
    ListNode p1 = dummy1, p2 = dummy2;
    // p 负责遍历原链表，类似合并两个有序链表的逻辑
    // 这里是将一个链表分解成两个链表
    ListNode p = head;
    while (p != null) {
        if (p.val >= x) {
            p2.next = p;
            p2 = p2.next;
        } else {
            p1.next = p;
            p1 = p1.next;
        }
        // 断开原链表中的每个节点的 next 指针
        ListNode temp = p.next;
        p.next = null;
        p = temp;
    }
    // 连接两个链表
    p1.next = dummy2.next;

    return dummy1.next;
}
```

> 注意：

十分要注意断开原链表中的每个节点的`next`指针，为何？因为不断开的话，此时`p1`,`p2`指针的`next `指向的是原链表中的某个地方，这样最终结果中最后一个元素本该指向`nullptr`却指向原链表某个地方。

#### **自我总结**

分解需要让原链表一分为二，则可创建两个链表（加头结点），把大于等于`x`的放一个链表，小于等于`x`的放一个链表。



### 单链表的倒数第 k 个节点

如何只需遍历一次链表的解法？

假设` k = 2`，思路如下：

首先，我们先让一个指针 `p1` 指向链表的头节点 `head`，然后走 `k` 步：

![image.png](https://note.youdao.com/yws/res/12154/WEBRESOURCE713a45ff82d2244470f0cd22fca2ae9f)

现在的` p1`，只要再走 `n - k` 步，就能走到链表末尾的空指针了对吧？

趁这个时候，再用一个指针` p2 `指向链表头节点 `head`：

![image.png](https://note.youdao.com/yws/res/12157/WEBRESOURCEe6d1d4c5653555cdb64e7c6f4d412d39)

接下来就很显然了，让 `p1` 和` p2` 同时向前走，`p1 `走到链表末尾的空指针时前进了 `n - k` 步，`p2` 也从` head `开始前进了 `n - k `步，停留在第` n - k + 1` 个节点上，即恰好停链表的倒数第` k `个节点上：

![image.png](https://note.youdao.com/yws/res/12161/WEBRESOURCE819c9b3336fc6f12c273316129f7e17d)

这样，只遍历了一次链表，就获得了倒数第` k` 个节点` p2`。

```c
// 返回链表的倒数第 k 个节点
ListNode findFromEnd(ListNode head, int k) {
    ListNode p1 = head;
    // p1 先走 k 步
    for (int i = 0; i < k; i++) {
        p1 = p1.next;
    }
    ListNode p2 = head;
    // p1 和 p2 同时走 n - k 步
    while (p1 != null) {
        p2 = p2.next;
        p1 = p1.next;
    }
    // p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点
    return p2;
}
```

![image.png](https://note.youdao.com/yws/res/12167/WEBRESOURCE6f8425394d7c676ad1eb958d0bfeba15)

```c
// 主函数
public ListNode removeNthFromEnd(ListNode head, int n) {
    // 虚拟头结点
    ListNode dummy = new ListNode(-1);
    dummy.next = head;
    // 删除倒数第 n 个，要先找倒数第 n + 1 个节点
    ListNode x = findFromEnd(dummy, n + 1);
    // 删掉倒数第 n 个节点
    x.next = x.next.next;
    return dummy.next;
}

private ListNode findFromEnd(ListNode head, int k) {
    // 代码见上文
}
```

> 注意：

要使用头结点，因为题目要删除倒数第`n`个节点，我们是找倒数第`n+1`个节点，如何此时倒数第`n`个节点刚好为第一个节点，此时会发生错误，所以使用虚拟头节点。

增加前面的节点，对于题目要求的节点，其索引位置不变，因为计算的是倒数第`n`个，不管前面怎么加，从后数还是不变。

#### **自我总结**

求倒数第`k`个节点

1. 让一个指针 `p1` 指向链表的头节点` head`，然后走 `k` 步

2. 现在的` p1`，只要再走` n - k `步，所以再用一个指针 `p2` 指向链表头节点 `head`，让 `p1` 和` p2` 同时向前走，`p1` 走到链表末尾的空指针时前进了 `n - k` 步，`p2` 也从 `head `开始前进了` n - k` 步，停留在第 `n - k + 1` 个节点上，即恰好停链表的倒数第` k `个节点上。

3. 注意使用头节点，避免计算到第一个点时，前面为`nullptr`的情况。


### 单链表的中点

使用「快慢指针」的技巧：

我们让两个指针` slow` 和 `fast` 分别指向链表头结点 `head`。每当慢指针 `slow` 前进一步，快指针` fast` 就前进两步，这样，当 `fast` 走到链表末尾时，`slow` 就指向了链表中点。

```c
ListNode middleNode(ListNode head) {
    // 快慢指针初始化指向 head
    ListNode slow = head, fast = head;
    // 快指针走到末尾时停止
    while (fast != null && fast.next != null) {
        // 慢指针走一步，快指针走两步
        slow = slow.next;
        fast = fast.next.next;
    }
    // 慢指针指向中点
    return slow;
}
```

> 注意

如果链表长度为偶数，也就是说中点有两个的时候，这个解法返回的节点是靠后的那个节点。

### 判断链表是否包含环

每当慢指针 `slow` 前进一步，快指针 `fast` 就前进两步。

如果 `fast `最终遇到空指针，说明链表中没有环；如果` fast `最终和 `slow` 相遇，那肯定是 `fast` 超过了 `slow` 一圈，说明链表中含有环。

```c
boolean hasCycle(ListNode head) {
    // 快慢指针初始化指向 head
    ListNode slow = head, fast = head;
    // 快指针走到末尾时停止
    while (fast != null && fast.next != null) {
        // 慢指针走一步，快指针走两步
        slow = slow.next;
        fast = fast.next.next;
        // 快慢指针相遇，说明含有环
        if (slow == fast) {
            return true;
        }
    }
    // 不包含环
    return false;
}
```

### 找到链表环的起点

![image.png](https://labuladong.github.io/algo/images/%E9%93%BE%E8%A1%A8%E6%8A%80%E5%B7%A7/circularlinkedlist.png)

```c
ListNode detectCycle(ListNode head) {
    ListNode fast, slow;
    fast = slow = head;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast == slow) break;        



    }
    // 上面的代码类似 hasCycle 函数
    if (fast == null || fast.next == null) {
        // fast 遇到空指针说明没有环
        return null;
    }

    // 重新指向头结点
    slow = head;    



    // 快慢指针同步前进，相交点就是环起点
    while (slow != fast) {
        fast = fast.next;
        slow = slow.next;
    }
    return slow;
}
```

当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。

我们假设快慢指针相遇时，慢指针` slow` 走了 `k` 步，那么快指针 `fast` 一定走了 `2k` 步：
![image.png](https://note.youdao.com/yws/res/12248/WEBRESOURCEe76f5e5a0c1ffd65423c7e6ec2e51303)

`fast` 一定比 `slow` 多走了` k` 步，这多走的` k `步其实就是` fast` 指针在环里转圈圈，所以 `k `的值就是环长度的「整数倍」。

假设相遇点距环的起点的距离为 `m`，那么结合上图的 `slow` 指针，环的起点距头结点 `head` 的距离为 `k - m`，也就是说如果从 `head` 前进 `k - m` 步就能到达环起点。

巧的是，如果从相遇点继续前进 `k - m` 步，也恰好到达环起点。因为结合上图的` fast` 指针，从相遇点开始走k步可以转回到相遇点，那走` k - m` 步肯定就走到环起点了：

![image.png](https://note.youdao.com/yws/res/12251/WEBRESOURCEcf56fe700d0b6d8f8d5b5a09f762e75d)

只要我们把快慢指针中的任一个重新指向 `head`，然后两个指针同速前进，`k - m` 步后一定会相遇，相遇之处就是环的起点了。

#### **自我总结**

1. 首先使用快慢指针的方法，快指针每步走`2k`，慢指针每步走`k`，如果存在环，则会相遇，如果不存在环，则不会相遇。即循环完后 如果`quick == nullptr || quick->next == nullptr`，则没有环。

2. 此时环起点距离相遇点为`m`，将快慢指针中任一个指向`head`，该指针到环起点的距离为`k-m`，因为`head`距离相遇点为 `k`，而在环内，相遇点距离环起点需要走的距离也是`k-m`，所以此时两个指针同时前进，`k-m`后相遇，其相遇的点为环起点。


### 两个链表是否相交

函数签名:

```c
ListNode getIntersectionNode(ListNode headA, ListNode headB);
```

给你输入两个链表的头结点 `headA` 和 `headB`，这两个链表可能存在相交。

如果相交，你的算法应该返回相交的那个节点；如果没相交，则返回 `nullptr`.

![](https://labuladong.github.io/algo/images/%E9%93%BE%E8%A1%A8%E6%8A%80%E5%B7%A7/4.png)

那么我们的算法应该返回` c1` 这个节点。
如果不用额外的空间，只使用两个指针，你如何做呢？

![image.png](https://note.youdao.com/yws/res/12291/WEBRESOURCEb67403deee675b144150f2e13e3ba8b8)

如果用两个指针 `p1 `和 `p2` 分别在两条链表上前进，并不能同时走到公共节点，也就无法得到相交节点` c1`。

解决这个问题的关键是，通过某些方式，让 `p1` 和 `p2` 能够同时到达相交节点 `c1`。

我们可以让 `p1` 遍历完链表 `A` 之后开始遍历链表 `B`，让` p2` 遍历完链表` B` 之后开始遍历链表 `A`，这样相当于「逻辑上」两条链表接在了一起。

如果这样进行拼接，就可以让 `p1` 和` p2` 同时进入公共部分，也就是同时到达相交节点 `c1`：

![image.png](https://note.youdao.com/yws/res/12297/WEBRESOURCE19b14065388e7b8e5ac00a89acb65516)

```c
如果说两个链表没有相交点,相当于 `c1` 节点是 `nullptr` 空指针，返回 `nullptr`。

ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    // p1 指向 A 链表头结点，p2 指向 B 链表头结点
    ListNode p1 = headA, p2 = headB;
    while (p1 != p2) {
        // p1 走一步，如果走到 A 链表末尾，转到 B 链表
        if (p1 == null) p1 = headB;
        else            p1 = p1.next;
        // p2 走一步，如果走到 B 链表末尾，转到 A 链表
        if (p2 == null) p2 = headA;
        else            p2 = p2.next;
    }
    return p1;
}
```

#### **自我总结**

1. 要求两个链表是否相交并且返回交点，抓住一个点，两条链表的总长度不变，由于不用额外空间，所以可以先 同时让`p1`遍历链表`B`，让`p2`遍历链表`A`，都遍历完后再让`p1`遍历链表`A`,让`p2`遍历链表`B`,此时的交点如果不为`nullptr`，那么为交点，如果为`nullptr`，则不相交。

2. 为何？抓住链表相交，后面的元素相同，所以此时确定一个总长度，两个链表之和，一个走`A`排前`B`排后，一个走`B`排前，`A`排后，元素相同即到相交元素。

3. 另一个方法：将一个链表的最后连到另一个链表的`head`上，即求是否有环，环的起点。

![image.png](https://note.youdao.com/yws/res/12330/WEBRESOURCEbfbdf3741c88a046a0336d07efebf1d0)

但是要注意：不让改变原始链表的结构，所以把题目输入的链表转化成环形链表求解之后记得还要改回来，否则无法通过。

### 合并K个有序链表

```c
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        int size = lists.size();
        // 虚拟头结点
        ListNode* dummy = new ListNode(-1);
        ListNode* p = dummy;
        // 优先级队列，最小堆
        priority_queue<ListNode*, vector<ListNode*>, compare > pq;
        // 将 k 个链表的头结点加入最小堆
        for (auto head : lists) {
            if (head) pq.push(head);
        }

        while (!pq.empty()) {
            // 获取最小节点，接到结果链表中
            auto node = pq.top();
            pq.pop();
            p->next = node;
            if (node->next) {
                pq.push(node->next);
            }
            // p 指针不断前进
            p = p->next;
        }
        return dummy->next;
    }
private:
    // 自定义比较函数
    struct compare {
        bool operator() (ListNode* a, ListNode* b) {
            return a->val > b->val;
        }
    };
};
```

分析：

1.  关于优先队列`priority_queue`

结构：

```c  
template <class T, class Container = vector<T>,  class Compare = less<typename Container::value_type> > class priority_queue;
```

T:元素类型
Container：底层容积类型
Compare:比较函数结构体

关于Compare，需要定义一个结构体，重载`()`运算符，然后将这个结构体当成优先队列的第三个参数。

```c
1 //升序队列，小顶堆
2 priority_queue <int,vector<int>,greater<int> > q;
3 //降序队列，大顶堆
4 priority_queue <int,vector<int>,less<int> >q;
5 
6 //greater和less是std实现的两个仿函数
  //（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）
  
priority_queue<vector<int>, vector<vector<int>>,greater<vector<int>>>pq([](const vector<int>& a, const vector<int>& b) {
    // 按照数对的元素和升序排序
    return a[0] + a[1] < b[0] + b[1];
});
```

2. 新建一个链表，将每个链表的头结点放入优先队列（因为每个链表是已经排序了的，因为看先从哪个开始）。

3. 读取并记录队列第一位，将队列第一位去掉。将记录下来的节点并入新建的链表。

4. 将记录所在的链表跳至下一位，并加入队列。

5. 新建的链表不断前进

## 反转单链表

链表结构：

```c
// 单链表节点的结构
class ListNode {
public:
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};
```

### 递归反转整个链表

![image.png](https://note.youdao.com/yws/res/12507/WEBRESOURCEaccfe0579944bfa6c1b96761a50910c2)

- 法1：递归法

```
// 定义：输入一个单链表头结点，将该链表反转，返回新的头结点
ListNode* reverse(ListNode* head) {
    if (head == nullptr || head->next == nullptr) {
        return head;
    }
    ListNode* last = reverse(head->next);
    head->next->next = head;
    head->next = nullptr;
    return last;
}
```

**对于递归算法，最重要的就是明确递归函数的定义**

`reverse` 函数定义：输入一个节点` head`，将「以 `head` 为起点」的链表反转，并返回反转之后的头结点。

![image.png](https://note.youdao.com/yws/res/12531/WEBRESOURCE44734090a2b76149ddde5e8acfc79c08)

输入 `reverse(head)` 后，会在这里进行递归：

```c
ListNode last = reverse(head.next);
```

**要根据刚才的函数定义，来弄清楚这段代码会产生什么结果，而不是通过跳入递归过程**
！！十分要注意

![image.png](https://note.youdao.com/yws/res/12538/WEBRESOURCE94e13386e21ba9501f6d1ab7a80fc0a1)

`reverse(head.next)` 执行完成后，整个链表就成了这样：

![image.png](https://note.youdao.com/yws/res/12541/WEBRESOURCEb6a2c00914ce8ae615305b8cf8730e5c)

并且根据函数定义，`reverse `函数会返回反转之后的头结点，我们用变量 `last` 接收了。


```c
head.next.next = head;
```

![image.png](https://note.youdao.com/yws/res/12545/WEBRESOURCE47b69bc7d0086eaba53b9725f248978d)


```c
head.next = null;
return last;
```

![image.png](https://note.youdao.com/yws/res/12548/WEBRESOURCE994702d55d3d6f73327062e393134b9b)


注意：

1. 递归函数要有 `base case`，也就是这句：
```c
if (head == null || head.next == null) {
    return head;
}
```

2. 当链表递归反转之后，新的头结点是` last`，而之前的 `head` 变成了最后一个节点，别忘了链表的末尾要指向 `null`：

```c
head.next = null;
```

- 双指针法

```c
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* temp; // 保存cur的下一个节点
        ListNode* cur = head;
        ListNode* pre = NULL;
        while(cur) {
            temp = cur->next;  // 保存一下 cur的下一个节点，因为接下来要改变cur->next
            cur->next = pre; // 翻转操作
            // 更新pre 和 cur指针
            pre = cur;
            cur = temp;
        }
        return pre;
    }
};
```

#### **自我总结**

不要跳入递归函数的递归步骤，先明白递归函数的含义和目的，通过递归的结果优化递归的过程。而且递归函数还需要base case来终止递归！

比如 需要反转一个链表，输入`base case`语句，调用反转函数反转除第一个以外的后面所有的链表，将第二个链表的`next`指向第一个（原本指向`nullptr`），同时，将第一个链表的`next`指向`nullptr`（原本指向第二个）。


### 反转链表前N个节点

```c
// 将链表的前 n 个节点反转（n <= 链表长度）
ListNode* reverseN(ListNode* head, int n)
```

比如说对于下图链表，执行 `reverseN(head, 3)`：

![](https://labuladong.github.io/algo/images/%e5%8f%8d%e8%bd%ac%e9%93%be%e8%a1%a8/6.jpg)

```c
ListNode* successor = nullptr; // 后驱节点

// 反转以 head 为起点的 n 个节点，返回新的头结点
ListNode* reverseN(ListNode* head, int n) {
    if (n == 1) {
        // 记录第 n + 1 个节点
        successor = head->next;
        return head;
    }
    // 以 head->next 为起点，需要反转前 n - 1 个节点
    ListNode* last = reverseN(head->next, n - 1);

    head->next->next = head;
    // 让反转之后的 head 节点和后面的节点连起来
    head->next = successor;
    return last;
}
```

具体的区别：

1. `base case` 变为 `n == 1`，反转一个元素，就是它本身，同时要记录后驱节点。

2. 刚才我们直接把` head.next` 设置为 `null`，因为整个链表反转后原来的 `head` 变成了整个链表的最后一个节点。但现在 `head` 节点在递归反转之后不一定是最后一个节点了，所以要记录后驱 `successor`（第 `n + 1` 个节点），反转之后将` head` 连接上。


![](https://labuladong.github.io/algo/images/%e5%8f%8d%e8%bd%ac%e9%93%be%e8%a1%a8/7.jpg)


#### **自我总结**

反转前`N`个节点方法和全部反转相似。

递归函数：反转前`N`个，每次递归，少一个 ，所以其参数要`n-1`。
终止条件：当只有1个元素需要递归时终止。并且需要有一个指针，指向该点的后一个元素（从这点开始不反转）。
修正：反转后的最后一个元素要指向反转前的第一个元素，反转前的第一个元素要指向后面不需要反转的链表。

注意：后驱节点初始化要写在函数体外，因为如果写在函数体内，到第一个递归函数又初始化回去了。

### 反转链表的一部分

给一个索引区间 [m, n]（索引从 1 开始），仅仅反转区间中的链表元素。

```c
ListNode reverseBetween(ListNode head, int m, int n)
```

如果 m == 1，就相当于反转链表开头的 n 个元素嘛，也就是我们刚才实现的功能：

```c
ListNode reverseBetween(ListNode head, int m, int n) {
    // base case
    if (m == 1) {
        // 相当于反转前 n 个元素
        return reverseN(head, n);
    }
    // ...
}
```

如果 `m != 1` 怎么办？通过递归向后移动，起点也会逐步向后移动，直至`m == 1`。
但需要注意的是，要将前面的链表保留下来，所以逐步将`head.next = last`。

我们把 `head` 的索引视为 `1`，那么我们是想从第 `m `个元素开始反转对吧；如果把 `head.next` 的索引视为 `1` 呢？那么相对于 `head.next`，反转的区间应该是从第` m - 1` 个元素开始的；那么对于 `head.next.next` 呢……

```c
ListNode reverseBetween(ListNode head, int m, int n) {
    // base case
    if (m == 1) {
        return reverseN(head, n);
    }
    // 前进到反转的起点触发 base case
    head.next = reverseBetween(head.next, m - 1, n - 1);
    return head;
}
```

#### **自我总结**

要反转一个区间，思路相似，确定相应的迭代函数，终止条件和修正。

迭代函数：头结点，左右索引，每进行一次迭代，其左右索引都-1，头结点为`head->next`。
终止条件：每进行一次迭代，都进行左移，当`left == 1`时，调用前N个链表反转的函数。
修正：要将前面`left-1`个节点连接到反转后的节点，所以`head.next = reverseBetween()`。


### K个一组反转链表

![image.png](https://note.youdao.com/yws/res/12629/WEBRESOURCE0edcc3c376e8a05bad7718064e04f783)

1. 分析问题：

**这个问题具有递归性质。**

什么叫递归性质？

比如说我们对这个链表调用 `reverseKGroup(head, 2)`，即以 2 个节点为一组反转链表：

![image.png](https://note.youdao.com/yws/res/12636/WEBRESOURCEef2c18862e1dd36d17a5b8448ebfc6a1)

如果我设法把前 2 个节点反转，那么后面的那些节点怎么处理？后面的这些节点也是一条链表，而且规模（长度）比原来这条链表小，这就叫子问题。

![image.png](https://note.youdao.com/yws/res/12640/WEBRESOURCE3d09fb61644fcdf804009d6c1e58d6e6)

我们可以把原先的 `head` 指针移动到后面这一段链表的开头，然后继续递归调用 `reverseKGroup(head, 2)`，因为子问题（后面这部分链表）和原问题（整条链表）的结构完全相同，这就是所谓的递归性质。

发现了递归性质，就可以得到大致的算法流程:

- 先反转以` head` 开头的` k `个元素。
- 将第 `k + 1` 个元素作为` head `递归调用 `reverseKGroup` 函数。
- 将上述两个过程的结果连接起来。
- `base case`:最后的元素不足 `k `个，就保持不变


```c
ListNode* reverseKGroup(ListNode* head, int k) {
    if (head == nullptr) return nullptr;
    // 区间 [a, b) 包含 k 个待反转元素
    ListNode *a, *b;
    a = b = head;
    for (int i = 0; i < k; i++) {
        // 不足 k 个，不需要反转，base case
        if (b == nullptr) return head;
        b = b->next;
    }
    // 反转前 k 个元素
    ListNode *newHead = reverse(a, b);
    // 递归反转后续链表并连接起来
    a->next = reverseKGroup(b, k);
    return newHead;
}
```

`reverse` 函数是反转区间 `[a, b)`

`reverse`函数：

要实现一个 `reverse `函数反转一个区间之内的元素。在此之前我们再简化一下，给定链表头结点，如何反转整个链表？

```c
// 反转以 a 为头结点的链表
ListNode* reverse(ListNode* a) {
    ListNode *pre, *cur, *nxt;
    pre = nullptr;
    cur = a;
    nxt = a;
    while (cur != nullptr) {
        nxt = cur->next;
        // 逐个结点反转
        cur->next = pre;
        // 更新指针位置
        pre = cur;
        cur = nxt;
    }
    // 返回反转后的头结点
    return pre;
}
```

![](https://labuladong.github.io/algo/images/kgroup/8.gif)

「反转以` a` 为头结点的链表」其实就是「反转` a` 到 `null` 之间的结点」，那么如果让你「反转 `a` 到` b` 之间的结点」,只要更改函数签名，并把上面的代码中 `null` 改成` b` 即可：

```c
// 反转区间 [a, b) 的元素，注意是左闭右开
ListNode* reverse(ListNode* a, ListNode* b) {
    ListNode *pre, *cur, *nxt;
    pre = nullptr; cur = a; nxt = a;
    // while 终止的条件改一下就行了
    while (cur != b) {
        nxt = cur->next;
        cur->next = pre;
        pre = cur;
        cur = nxt;
    }
    // 返回反转后的头结点
    return pre;
}
```

最终：
![](https://labuladong.github.io/algo/images/kgroup/7.jpg)


#### **自我总结**

如何会想到用递归函数？有递归性质即可用递归函数

> 子问题（后面这部分链表）和原问题（整条链表）的结构完全相同，这就是所谓的递归性质。

递归函数：头结点、k个递归，每次迭代，头结点都为更新的头结点
终止函数：`head == nullptr`，不足`k`个元素，终止迭代
修正：每次需要更正需要反转的范围，将反转后的头结点保留，作为`return`，每次递归反转后，需要将后续的链表连接起来。

一个区间[a,b）反转：迭代思路：


初始化三个节点，一个`pre`保留上一个节点，一个`cur`保留当前节点，一个`nxt`保留下一个节点，开始时，`pre == nullptr`，`cur == head` ,`nxt == head`，每次循环，`nxt = cur->next`，`cur->next = pre`，更新位置，`pre = cur `,`cur = nxt`。终止条件为当`cur == b`时，终止。返回`pre`节点。



# 数学运算技巧

## 寻找素数

如果你要判断一个数是不是素数，应该如何写算法。

```c
int countPrimes(int n) {
    int count = 0;
    for (int i = 2; i < n; i++)
        if (isPrime(i)) count++;
    return count;
}

// 判断整数 n 是否是素数
boolean isPrime(int n) {
    for (int i = 2; i < n; i++)
        if (n % i == 0)
            // 有其他整除因子
            return false;
    return true;
}
```

此方法时间复杂度很高，需要优化。

稍微修改一下上面的 isPrime 代码中的 for 循环条件：

```c
boolean isPrime(int n) {
    for (int i = 2; i * i <= n; i++)
        ...
}
```

为何只要计算到`sqrt(n)`？举个例子，假设 n = 12。

```c
12 = 2 × 6
12 = 3 × 4
12 = sqrt(12) × sqrt(12)
12 = 4 × 3
12 = 6 × 2
```

后两个乘积就是前面两个反过来，反转临界点就在 `sqrt(n)`。如果在` [2,sqrt(n)]` 这个区间之内没有发现可整除因子，就可以直接断定` n` 是素数了，因为在区间 `[sqrt(n),n]` 也一定不会发现可整除因子。


接下来介绍的方法叫做「素数筛选法」。

素数筛选法的核心思路是和上面的常规思路反着来：

首先从 2 开始，我们知道 2 是一个素数，那么 2 × 2 = 4, 3 × 2 = 6, 4 × 2 = 8… 都不可能是素数了。

然后我们发现 3 也是素数，那么 3 × 2 = 6, 3 × 3 = 9, 3 × 4 = 12… 也都不可能是素数了。

![](https://labuladong.github.io/algo/images/prime/1.gif)


第一版代码：

```c
int countPrimes(int n) {
    boolean[] isPrime = new boolean[n];
    // 将数组都初始化为 true
    Arrays.fill(isPrime, true);

    for (int i = 2; i < n; i++) 
        if (isPrime[i]) 
            // i 的倍数不可能是素数了
            for (int j = 2 * i; j < n; j += i) 
                    isPrime[j] = false;
    
    int count = 0;
    for (int i = 2; i < n; i++)
        if (isPrime[i]) count++;
    
    return count;
}
```

由于因子的对称性，其中的 `for` 循环只需要遍历` [2,sqrt(n)] `就够了。
内层的 `for` 循环也可以优化。比如 n = 25，i = 5 时算法会标记 5 × 2 = 10，5 × 3 = 15 等等数字，但是这两个数字已经被 i = 2 和 i = 3 的 2 × 5 和 3 × 5 标记了。

我们可以稍微优化一下，让 j 从 i 的平方开始遍历，而不是从 2 * i 开始：

完整的最终代码：叫做 Sieve of Eratosthenes

```c
int countPrimes(int n) {
    boolean[] isPrime = new boolean[n];
    Arrays.fill(isPrime, true);
    for (int i = 2; i * i < n; i++) 
        if (isPrime[i]) 
            for (int j = i * i; j < n; j += i) 
                isPrime[j] = false;
    
    int count = 0;
    for (int i = 2; i < n; i++)
        if (isPrime[i]) count++;
    
    return count;
}
```

## 丑数

### 丑数I

题目：
> 给你输入一个数字`n`，请你判断n是否为「丑数」。所谓「丑数」，就是只包含质因数2、3和5的正整数。

既然任意一个大于一的正整数都可以分解成若干质数的乘积，那么丑数也可以被分解成若干质数的乘积，且这些质数只能是 2, 3 或 5。

解答：

```c
public boolean isUgly(int n) {
    if (n <= 0) return false;
    // 如果 n 是丑数，分解因子应该只有 2, 3, 5
    while (n % 2 == 0) n /= 2;
    while (n % 3 == 0) n /= 3;
    while (n % 5 == 0) n /= 5;
    // 如果能够成功分解，说明是丑数
    return n == 1;
}
```

### 丑数II

题目：

> 给你一个整数 n ，请你找出并返回第 n 个 丑数 。丑数 就是只包含质因数 2、3 和/或 5 的正整数。


分析：

现在题目不是让你判断一个数是不是丑数，而是给你输入一个n，让你计算第n个丑数是多少，函数签名如下：

```c
int nthUglyNumber(int n)
```

如果一个数x是丑数，那么x * 2, x * 3, x * 5都一定是丑数。

如果我们把所有丑数想象成一个从小到大排序的链表，就是这个样子：
`1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 8 -> ...`

我们可以把丑数分为三类：2 的倍数、3 的倍数、5 的倍数。这三类丑数就好像三条有序链表，如下：

能被 2 整除的丑数：

`1*2 -> 2*2 -> 3*2 -> 4*2 -> 5*2 -> 6*2 -> 8*2 ->...`

能被 3 整除的丑数：

`1*3 -> 2*3 -> 3*3 -> 4*3 -> 5*3 -> 6*3 -> 8*3 ->...`

能被 5 整除的丑数：

`1*5 -> 2*5 -> 3*5 -> 4*5 -> 5*5 -> 6*5 -> 8*5 ->...`

我们如果把这三条「有序链表」合并在一起并去重，得到的就是丑数的序列，其中第n个元素就是题目想要的答案：

`1 -> 1*2 -> 1*3 -> 2*2 -> 1*5 -> 3*2 -> 4*2 ->...`

答案：

```c
int nthUglyNumber(int n) {
    // 可以理解为三个指向有序链表头结点的指针
    int p2 = 1, p3 = 1, p5 = 1;
    // 可以理解为三个有序链表的头节点的值
    int product2 = 1, product3 = 1, product5 = 1;
    // 可以理解为最终合并的有序链表（结果链表）
    int[] ugly = new int[n + 1];
    // 可以理解为结果链表上的指针
    int p = 1;

    // 开始合并三个有序链表，找到第 n 个丑数时结束
    while (p <= n) {
        // 取三个链表的最小结点
        int min = Math.min(Math.min(product2, product3), product5);
        // 将最小节点接到结果链表上
        ugly[p] = min;
        p++;
        // 前进对应有序链表上的指针
        if (min == product2) {
            product2 = 2 * ugly[p2];
            p2++;
        }
        if (min == product3) {
            product3 = 3 * ugly[p3];
            p3++;
        }
        if (min == product5) {
            product5 = 5 * ugly[p5];
            p5++;
        }
    }
    // 返回第 n 个丑数
    return ugly[n];
}
```

我们用`p2`, `p3`, `p5`分别代表三条丑数链表上的指针，用`product2`, `product3`, `product5`代表丑数链表上节点的值，用ugly数组记录有序链表合并之后的结果。

注意：先取三个链表的最小值（确保按照顺序排），记录相应链表的位置，乘的是`ugly[p2]`结果链表的位置！


### 超级丑数

题目：

> 超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 `primes `中。给你一个整数 `n `和一个整数数组 `primes` ，返回第 `n `个 超级丑数 。

函数签名如下：

`int nthSuperUglyNumber(int n, int[] primes)`

注意我们在上道题抽象出了三条链表，需要`p2`, `p3`, `p5`作为三条有序链表上的指针，同时需要`product2`, `product3`, `product5`记录指针所指节点的值，每次循环用min函数计算最小头结点。

这道题相当于输入了`len(primes)`条有序链表，我们不能用`min`函数计算最小头结点了，而是要用优先级队列来计算最小头结点，同时依然要维护链表指针、指针所指节点的值，我们可以用一个三元组来保存这些信息。

```c
int nthSuperUglyNumber(int n, int[] primes) {
    // 优先队列中装三元组 int[] {product, prime, pi}
    // 其中 product 代表链表节点的值，prime 是计算下一个节点所需的质数因子，pi 代表链表上的指针
    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {
        // 优先级队列按照节点的值排序
        return a[0] - b[0];
    });

    // 把多条链表的头结点加入优先级队列
    for (int i = 0; i < primes.length; i++) {
        pq.offer(new int[]{ 1, primes[i], 1 });
    }

    // 可以理解为最终合并的有序链表（结果链表）
    int[] ugly = new int[n + 1];
    // 可以理解为结果链表上的指针
    int p = 1;

    while (p <= n) {
        // 取三个链表的最小结点
        int[] pair = pq.poll();
        int product = pair[0];
        int prime = pair[1];
        int index = pair[2];

        // 避免结果链表出现重复元素
        if (product != ugly[p - 1]) {
            // 接到结果链表上
            ugly[p] = product;
            p++;
        }

        // 生成下一个节点加入优先级队列
        int[] nextPair = new int[]{ugly[index] * prime, prime, index + 1};
        pq.offer(nextPair);
    }
    return ugly[n];
}
```

注意： 此时优先队列存储的信息，节点值，相应的质数，指针位置


### 丑数III

题目：

> 给你四个整数：n, a, b, c，请你设计一个算法来找出第n个丑数。其中丑数是可以被a或b或c整除的正整数。

分析：

这道题和之前题目的不同之处在于它改变了「丑数」的定义，只要一个正整数x存在a, b, c中的任何一个因子，那么x就是丑数。

可以想到把a, b, c的倍数抽象成三条有序链表：

```
1*3 -> 2*3 -> 3*3 -> 4*3 -> 5*3 -> 6*3 -> 7*3 ->...
1*4 -> 2*4 -> 3*4 -> 4*4 -> 5*4 -> 6*4 -> 7*4 ->...
1*5 -> 2*5 -> 3*5 -> 4*5 -> 5*5 -> 6*5 -> 7*5 ->...
```
然后将这三条链表合并成一条有序链表并去除重复元素，这样合并后的链表元素就是丑数序列，我们从中找到第n个元素即可：

```
1*3 -> 1*4 -> 1*5 -> 2*3 -> 2*4 -> 3*3 -> 2*5 ->...
```

有了这个思路，可以直接写出代码：

```c
public int nthUglyNumber(int n, int a, int b, int c) {
    // 可以理解为三个有序链表的头结点的值
    // 由于数据规模较大，用 long 类型
    long productA = a, productB = b, productC = c;
    // 可以理解为合并之后的有序链表上的指针
    int p = 1;

    long min = -666;

    // 开始合并三个有序链表，获取第 n 个节点的值
    while (p <= n) {
        // 取三个链表的最小结点
        min = Math.min(Math.min(productA, productB), productC);
        p++;
        // 前进最小结点对应链表的指针
        if (min == productA) {
            productA += a;
        }
        if (min == productB) {
            productB += b;
        }
        if (min == productC) {
            productC += c;
        }
    }
    return (int) min;
}
```


但是提交之后并不能通过所有测试用例，会超时。

所以换一个思路。

首先，我们可以定义一个单调递增的函数`f`：

`f(num, a, b, c)`计算`[1..num]`中，能够整除`a`或`b`或`c`的数字的个数，显然函数`f`的返回值是随着num的增加而增加的（单调递增）。

题目让我们求第n个能够整除`a`或`b`或`c`的数字是什么，也就是说我们要找到一个最小的num，使得`f(num, a, b, c) == n`。

这个`num`就是第`n`个能够整除`a`或`b`或`c`的数字。

关键说一下函数f怎么实现，这里面涉及容斥原理以及最小公因数、最小公倍数的计算方法。

我把`[1..num]`中能够整除`a`的数字归为集合`A`，能够整除`b`的数字归为集合`B`，能够整除c的数字归为集合`C`，那么`len(A) = num / a`, `len(B) = num / b`, `len(C) = num / c`，这个很好理解。

但是`f(num, a, b, c)`的值肯定不是`num / a + num / b + num / c`这么简单，因为你注意有些数字可能可以被`a`,` b`, `c`中的两个数或三个数同时整除，如下图：

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdFsNibLuF4mGUoubxiapHxZNsXbpicSfgo9iaOgdng4hZTOAnzIB3icD0bR7xWnXbHbNrqr6icbSmEU7SCQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

按照容斥原理，这个集合中的元素应该是：`A + B + C - A ∩ B - A ∩ C - B ∩ C + A ∩ B ∩ C`。

`A ∩ B`的元素个数就是`num / lcm(a, b)`，其中`lcm`是计算最小公倍数（Least Common Multiple）的函数。

类似的，`A ∩ B ∩ C`的元素个数就是`num / lcm(lcm(a, b), c)`的值。

现在的问题是，最小公倍数怎么求？

直接记住定理吧：`lcm(a, b) = a * b / gcd(a, b)`，其中`gcd`是计算最大公因数（Greatest Common Divisor）的函数。

现在的问题是，最大公因数怎么求？这应该是经典算法了，我们一般叫辗转相除算法（或者欧几里得算法）。

#### 最小公倍数求法

```c
// 最小公倍数
long lcm(long a, long b) {
    // 最小公倍数就是乘积除以最大公因数
    return a * b / gcd(a, b);
}
```

#### 最大公因数求法

```c
long gcd(long a, long b) {
    if (a < b) {
        // 保证 a > b
        return gcd(b, a);
    }
    if (b == 0) {
        return a;
    }
    return gcd(b, a % b);
}
```

最终答案：

```c
// 二分搜索 + 数学解法
class Solution {
public:
    int nthUglyNumber(int n, int a, int b, int c) {
        // 题目说本题结果在 [1, 2 * 10^9] 范围内，
        // 所以就按照这个范围初始化两端都闭的搜索区间
        int left = 1, right = (int) 2e9;
        // 搜索左侧边界的二分搜索
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (f(mid, a, b, c) < n) {
                // [1..mid] 中的元素个数不足 n，所以目标在右侧
                left = mid + 1;
            } else {
                // [1..mid] 中的元素个数大于 n，所以目标在左侧
                right = mid - 1;
            }
        }
        return left;
    }

    // 计算 [1..num] 之间有多少个能够被 a 或 b 或 c 整除的数字
    long f(int num, int a, int b, int c) {
        long setA = num / a, setB = num / b, setC = num / c;
        long setAB = num / lcm(a, b);
        long setAC = num / lcm(a, c);
        long setBC = num / lcm(b, c);
        long setABC = num / lcm(lcm(a, b), c);
        // 集合论定理：A + B + C - A ∩ B - A ∩ C - B ∩ C + A ∩ B ∩ C
        return setA + setB + setC - setAB - setAC - setBC + setABC;
        /*
        ![](https://labuladong.github.io/pictures/丑数/1.jpg)
        */
    }

    // 计算最大公因数（辗转相除/欧几里得算法）
    long gcd(long a, long b) {
        if (a < b) {
            // 保证 a > b
            return gcd(b, a);
        }
        if (b == 0) {
            return a;
        }
        return gcd(b, a % b);
    }

    // 最小公倍数
    long lcm(long a, long b) {
        // 最小公倍数就是乘积除以最大公因数
        return a * b / gcd(a, b);
    }
};

// 用合并单链表的思路（超时）
class Solution2 {
public:
    int nthUglyNumber(int n, int a, int b, int c) {
        // 可以理解为三个有序链表的头结点的值
        long productA = a, productB = b, productC = c;
        // 可以理解为合并之后的有序链表上的指针
        int p = 1;

        long min = -666;

        // 开始合并三个有序链表，获取第 n 个节点的值
        while (p <= n) {
            // 取三个链表的最小结点
            min = std::min({productA, productB, productC});
            p++;
            // 前进最小结点对应链表的指针
            if (min == productA) {
                productA += a;
            }
            if (min == productB) {
                productB += b;
            }
            if (min == productC) {
                productC += c;
            }
        }
        return (int) min;
    }
};
```

## 如何寻找缺失和重复元素

### 错误的集合

![image.png](https://note.youdao.com/yws/res/21410/WEBRESOURCE89958ff6009d8814361881346dbbc454)

其实很容易解决这个问题，先遍历一次数组，用一个哈希表记录每个数字出现的次数，然后遍历一次 [1..N]，看看那个元素重复出现，那个元素没有出现，就 OK 了。

但问题是，这个常规解法需要一个哈希表，也就是O(N)的空间复杂度

> 如何降低空间复杂度，在 O(1) 的空间复杂度之下找到重复和缺失的元素？

如果说 nums 中不存在重复元素和缺失元素，那么每个元素就和唯一一个索引值对应,有一个元素重复了，同时导致一个元素缺失了，这会产生什么现象呢？会导致有两个元素对应到了同一个索引，而且会有一个索引没有元素对应过去。

通过某些方法，找到这个重复对应的索引，不就是找到了那个重复元素么？找到那个没有元素对应的索引，不就是找到了那个缺失的元素了么？

**通过将每个索引对应的元素变成负数，以表示这个索引被对应过一次了**

![](https://labuladong.github.io/algo/images/dupmissing/1.gif)

如果出现重复元素 4，直观结果就是，索引 4 所对应的元素已经是负数:

![image.png](https://note.youdao.com/yws/res/21423/WEBRESOURCE1e8cf4c22f5684bef3dcf4c70bef3f6a)

对于缺失元素 3，直观结果就是，索引 3 所对应的元素是正数：

![image.png](https://note.youdao.com/yws/res/21427/WEBRESOURCE2388447ed604729d8a5734c9ad50eb5e)

```c
class Solution {
public:
    vector<int> findErrorNums(vector<int>& nums) {
        int n=nums.size();
        int dup=-1;
        for(int i=0;i<n;i++){
            // 现在的元素是从1开始的
            int index = abs(nums[i])-1;
            if(nums[index]<0)
                dup = abs(nums[i]);
            else
                nums[index]*=-1;
        }
        int missing=-1;
        for(int i=0;i<n;i++)
            if(nums[i]>0)
                // 将索引转换成元素
                missing=i+1;
        return {dup,missing};
    }
};
```

> 这种方法只适用于正数的情况

## 位操作

### 判断两个数是否异号

```c
int x = -1, y = 2;
boolean f = ((x ^ y) < 0); // true

int x = 3, y = 2;
boolean f = ((x ^ y) < 0); // false
```

利用的是补码编码的符号位。整数编码最高位是符号位，负数的符号位是 `1`，非负数的符号位是 `0`，再借助异或的特性（bite相同为`0`不同为`1`），可以判断出两个数字是否异号。

### `index & (arr.length - 1)` 的运用

> 注意！这个技巧只适用于数组长度是 2 的幂次方的情况，比如 2、4、8、16、32 以此类推

环形数组，利用求模（余数）的方式让数组看起来头尾相接形成一个环形，永远都走不完:

```c
#include <iostream>
using namespace std;

int main() {
    int arr[] = {1, 2, 3, 4};
    int index = 0;
    while (true) {
        // 绕着循环数组走
        cout << arr[index % (sizeof(arr) / sizeof(int))] << endl;
        index++;
    }
    // 无法到达的代码
    return 0;
}
// 输出：1,2,3,4,1,2,3,4,1,2,3,4...
```

但模运算 `%` 对计算机来说其实是一个比较昂贵的操作，所以我们可以用 `&` 运算来求余数：`& (arr.length - 1)` 这个位运算能够替代 `% arr.length` 的模运算，性能会更好一些

如果你使用 `%` 求模的方式，那么当 `index` 小于 `0` 之后求模的结果也会出现负数，你需要特殊处理。但通过 & 与运算的方式，`index` 不会出现负数，依然可以正常工作

```c
int arr[] = {1,2,3,4};
int index = 0;
while (true) {
    // 在环形数组中转圈
    cout << arr[index & (sizeof(arr) / sizeof(*arr) - 1)] << " ";
    index--;
}
// 输出：1,4,3,2,1,4,3,2,1,4,3,2,1...
```

### `n & (n-1)` 的运用

作用是消除数字 `n` 的二进制表示中的最后一个 `1`

![](https://labuladong.github.io/algo/images/%e4%bd%8d%e6%93%8d%e4%bd%9c/1.png)

其核心逻辑就是，`n - 1` 一定可以消除最后一个 `1`，同时把其后的 `0` 都变成 `1`，这样再和 `n` 做一次 `&` 运算，就可以仅仅把最后一个 `1` 变成 `0` 了。

#### 位1的个数

> 分析

因为 `n & (n - 1)` 可以消除最后一个 `1`，所以可以用一个循环不停地消除 `1` 同时计数，直到 `n` 变成 `0` 为止。

```c
class Solution {
public:
    // you need to treat n as an unsigned value
    int hammingWeight(uint32_t n) {
        int res = 0;
        while (n != 0) {
            n = n & (n - 1);
            res++;
        }
        return res;
    }
};
```

### `a^a = 0`的运用

一个数和它本身做异或运算结果为 `0`，即 `a ^ a = 0`；一个数和 `0` 做异或运算的结果为它本身，即 `a ^ 0 = a`

#### 找不同

![image.png](https://note.youdao.com/yws/res/21493/WEBRESOURCE308cf07899eb20e08e6bcbdb1c7809a0)

我们可以把这两个字符串中所有字符拿出来做异或操作，这样相同的两个数字都抵消为 0 了，最终剩下的就是多出来的那个数字。时间复杂度 O(N)，空间复杂度 O(1)。

```c
class Solution {
public:
    char findTheDifference(string s, string t) {
        int res = 0;
        for (char c : s) {
            res = res ^ c;
        }
        for (char d : t) {
            res = res ^ d;
        }

        // 根据异或运算规则，所有字符的异或结果就是多出来的那个字符
        return (char) res;
    }
};
```

> 如何理解？

根据结合律，相当于 `0 ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ d ^ e`即等于`e`

#### 只出现一次的数字

![image.png](https://note.youdao.com/yws/res/21504/WEBRESOURCE752d5868ae9989a4d6778ebac904aa3c)

```c
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = 0;
        for (int n : nums) {
            res ^= n;
        }
        return res;
    }
};
```

#### 丢失的数字

![image.png](https://note.youdao.com/yws/res/21512/WEBRESOURCE90e35f9b438a3596e8048b2148b855e0)

我们先把索引补一位，然后让每个元素和自己相等的索引相对应：

```c
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int n = nums.size();
        int res = 0;
        // 先和新补的索引异或一下
        res ^= n;
        // 和其他的元素、索引做异或
        for (int i = 0; i < n; i++)
            res ^= i ^ nums[i];
        return res;
    }
};
```

# 栈

- 使用情况

需要用到栈的特性：先进后出

## 重排链表

![image.png](https://note.youdao.com/yws/res/15139/WEBRESOURCE7ade9d444608afff0e740d97da188a2e)

这题的难点在于：一个单链表只能从头部向尾部遍历节点，无法从尾部开始向头部遍历节点。

那么我们可以利用「栈」先进后出的结构特点，按从头到尾的顺序让链表节点入栈，那么出栈顺序就是反过来从尾到头了。

有了这个栈，算法的大致逻辑如下：

```cpp
ListNode p = head;
while (p != null) {
    // 链表尾部的节点
    ListNode lastNode = stk.pop();
    // 按题目要求拼接
    ListNode next = p.next;
    p.next = lastNode;
    lastNode.next = next;
    p = next;
}
```
当然，处理单链表时细节问题比较多，注意操作指针时的顺序，避免操作失误形成环形链表.

```cpp
class Solution {
public:
    void reorderList(ListNode* head) {
        stack<ListNode*> stk;
        // 先把所有节点装进栈里，得到倒序结果
        ListNode* p = head;
        while (p != nullptr) {
            stk.push(p);
            p = p->next;
        }

        p = head;
        while (p != nullptr) {
            // 链表尾部的节点
            ListNode* lastNode = stk.top();
            stk.pop();
            ListNode* next = p->next;
            if (lastNode == next || lastNode->next == next) {
                // 结束条件，链表节点数为奇数或偶数时均适用
                lastNode->next = nullptr;
                break;
            }
            p->next = lastNode;
            lastNode->next = next;
            p = next;
        }
    }
};
```

## 有效的括号

![image.png](https://note.youdao.com/yws/res/15364/WEBRESOURCEe745ed8c89a73141225291d738505475)

分析：每个右括号要对应一个左括号，且必须要正确顺序，所以可以考虑将左括号放入栈中，每读取到一个右括号，那么从栈顶去取一个字符做比较，如果此时栈为空或者栈不等于该字符对应的字符，那么判断为`flase`


```cpp
class Solution {
public:
    bool isValid(string str) {
        stack<char> left;
        for (char c : str) {
            if (c == '(' || c == '{' || c == '[')
                left.push(c);
            else // 字符 c 是右括号
                if (!left.empty() && leftOf(c) == left.top())
                    left.pop();
                else
                    // 和最近的左括号不匹配
                    return false;
        }
        // 是否所有的左括号都被匹配了
        return left.empty();
    }

    char leftOf(char c) {
        if (c == '}') return '{';
        if (c == ')') return '(';
        return '[';
    }
};
```


## 逆波兰表达式求值


![image.png](https://note.youdao.com/yws/res/15384/WEBRESOURCE78485705a9f46a6b78b4a4ab186e21a3)

![image.png](https://note.youdao.com/yws/res/15386/WEBRESOURCE728e1e0495f0d623759262bf7c4f2194)


分析：读取元素，如果是数字，放入栈中，如果是运算符号，取出两个元素，进行运算，将结果放入栈中。


```c
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> stk;
        for (const string& token : tokens) {
            if (string("+-*/").find(token) != string::npos) {
                // 是个运算符，从栈顶拿出两个数字进行运算，运算结果入栈
                int a = stk.top(); stk.pop();
                int b = stk.top(); stk.pop();
                switch (token[0]) {
                    case '+':
                        stk.push(a + b);
                        break;
                    case '*':
                        stk.push(a * b);
                        break;
                    // 对于减法和除法，顺序别搞反了，第二个数是被除（减）数
                    case '-':
                        stk.push(b - a);
                        break;
                    case '/':
                        stk.push(b / a);
                        break;
                }
            } else {
                // 是个数字，直接入栈即可
                stk.push(stoi(token));
            }
        }
        // 最后栈中剩下一个数字，即是计算结果
        return stk.top();
    }
};
```

注意：

关于`string::npos`
npos是一个静态的成员常量值，对于size_t类型的元素来说是最大的值。这个值在字符串的成员函数中作为len（或sublen）参数的值时，意味着 "直到字符串的结束"。作为一个返回值，它通常被用来表示没有匹配。

关于`stoi()`
将字符串转为整数，常见还有`atoi(str.c_str())`c方法。注意，字符串都要为`const`类型
将整数转为字符串，可以用`itoa()`c方法，或者`stringstream`。

## 使括号有效的最少添加

![image.png](https://note.youdao.com/yws/res/15403/WEBRESOURCE63d6cd3680829fdaffcb803db8f9c4a9)

分析：每有一个`(`，则需要一个`)`，当`）`数量大于需要的数量，则插入一个字符，最后加上需要`)`的字符。所以可以考虑设置一个参数`need`，当读取到`(`字符时，`need++`，当读取到`)`字符时，`need--`,当`need == -1`时，需要插入字符。

```c
class Solution {
public:
    int minAddToMakeValid(string s) {
        // res 记录插入次数
        int res = 0;
        // need 变量记录右括号的需求量
        int need = 0;

        for (int i = 0; i < s.length(); i++) {
            if (s[i] == '(') {
                // 对右括号的需求 + 1
                need++;
            }

            if (s[i] == ')') {
                // 对右括号的需求 - 1
                need--;

                if (need == -1) {
                    need = 0;
                    // 需插入一个左括号
                    res++;
                }
            }
        }

        return res + need;
    }
};
```


## 平衡括号字符串的最小插入次数

![image.png](https://note.youdao.com/yws/res/15418/WEBRESOURCE7728e9f5c80eb05803ea61420b3d894f)

分析：遍历字符串，通过一个 need 变量记录对右括号的需求数，根据 need 的变化来判断是否需要插入。当遇到左括号时，若对右括号的需求量为奇数，需要插入 1 个右括号，因为一个左括号需要两个右括号嘛，右括号的需求必须是偶数。

```c
class Solution {
public:
    int minInsertions(string s) {
        int res = 0, need = 0;

        for (int i = 0; i < s.length(); i++) {
            if (s[i] == '(') {
                need += 2;
                if (need % 2 == 1) {
                    res++;
                    need--;
                }
            }

            if (s[i] == ')') {
                need--;
                if (need == -1) {
                    res++;
                    need = 1;
                }
            }
        }

        return res + need;
    }
};
```

分析：
当读取到`(`时，`need +=2`，要考虑这种情况：`()(`,所以如果`need`为奇数时，说明有这种情况。那么此时添加`)`，`need--`。
当读取到`)`时，`need--`，但是要考虑这种情况：`)(`和`))(`,所以可以在左侧增加`(`，此时`need =1`，变为`()`。


## 用队列实现栈

题目：

```
225. 用队列实现栈

请你仅使用一个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push 、 top 、 pop 和 empty）。

实现 MyStack 类：

1、 void push(int x) 将元素 x 压入栈顶。

2、 int pop() 移除并返回栈顶元素。

3、 int top() 返回栈顶元素。

4、 boolean empty() 如果栈是空的，返回 true；否则，返回 false。
```

基本思路：

用队列实现栈就比较简单粗暴了，只需要一个队列作为底层数据结构。

底层队列只能向队尾添加元素，所以栈的 pop API 相当于要从队尾取元素：

![image.png](https://note.youdao.com/yws/res/16071/WEBRESOURCE724aa860c6e13a44707d4d3495c6c4c3)

那就把队尾元素前面的所有元素重新塞到队尾，让队尾元素排到队头，这样就可以取出了：

![image.png](https://note.youdao.com/yws/res/16074/WEBRESOURCE8e98db2583ccfa0792f4b84693bea581)

```cpp
class MyStack {
    queue<int> q;
    int top_elem = 0;

public:
    /**
     * 添加元素到栈顶
     */
    void push(int x) {
        // x 是队列的队尾，是栈的栈顶
        q.push(x);
        top_elem = x;
    }

    /**
     * 返回栈顶元素
     */
    int top() {
        return top_elem;
    }

    /**
     * 删除栈顶的元素并返回
     */
    int pop() {
        int size = q.size();
        // 留下队尾 2 个元素
        while (size > 2) {
            q.push(q.front());
            q.pop();
            size--;
        }
        // 记录新的队尾元素
        top_elem = q.front();
        q.push(q.front());
        q.pop();
        // 删除之前的队尾元素
        int temp = q.front();
        q.pop();
        return temp;
    }

    /**
     * 判断栈是否为空
     */
    bool empty() {
        return q.empty();
    }
};
```


## 用栈实现队列

题目：

```
232. 用栈实现队列

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：

实现 MyQueue 类：

void push(int x) 将元素 x 推到队列的末尾
int pop() 从队列的开头移除并返回元素
int peek() 返回队列开头的元素
boolean empty() 如果队列为空，返回 true ；否则，返回 false
说明：

你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。

示例 1：

输入：
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 1, 1, false]

解释：
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
```

思路：

我们使用两个栈 `s1`, `s2` 就能实现一个队列的功能。

当调用 `push` 让元素入队时，只要把元素压入 `s1` 即可：

![image.png](https://note.youdao.com/yws/res/16084/WEBRESOURCEf91072dbbea025548a42453146f6b49d)

使用 `peek` 或 `pop` 操作队头的元素时，若 `s2` 为空，可以把 `s1` 的所有元素取出再添加进 `s2`，这时候 `s2` 中元素就是先进先出顺序了：

![image.png](https://note.youdao.com/yws/res/16087/WEBRESOURCEa146b2bcd91380b54a2df298a2645748)

```cpp
class MyQueue {
private:
    stack<int> s1, s2;

public:
    MyQueue() {}

    /**
     * 添加元素到队尾
     */
    void push(int x) {
        s1.push(x);
    }

    /**
     * 删除队头的元素并返回
     */
    int pop() {
        // 先调用 peek 保证 s2 非空
        peek();
        int element = s2.top();
        s2.pop();
        return element;
    }

    /**
     * 返回队头元素
     */
    int peek() {
        if (s2.empty())
            // 把 s1 元素压入 s2
            while (!s1.empty()) {
                s2.push(s1.top());
                s1.pop();
            }
        return s2.top();
    }

    /**
     * 判断队列是否为空
     */
    bool empty() {
        return s1.empty() && s2.empty();
    }
};
```

## 最小栈

题目：

```
155. 最小栈

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

实现 MinStack 类:

MinStack() 初始化堆栈对象。
void push(int val) 将元素val推入堆栈。
void pop() 删除堆栈顶部的元素。
int top() 获取堆栈顶部的元素。
int getMin() 获取堆栈中的最小元素。
 

示例 1:

输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

分析：

根据我们之前亲自动手实现的栈，我们知道栈是一种操作受限的数据结构，只能从栈顶插入或弹出元素，所以对于标准的栈来说，如果想实现本题的 getMin 方法，只能老老实实把所有元素弹出来然后找最小值。

不过我们可以用「空间换时间」的思路来避免这种低效率的操作，用一个额外的栈 minStk 来记录栈中每个元素下面（到栈底）的最小元素是多少，这样就能快速得到整个栈中的最小元素了。


![image.png](https://note.youdao.com/yws/res/16100/WEBRESOURCE6a636c1d65c6ae23d9f055da9f669bb7)


可以做一些优化，减少 minStk 中存储的元素个数。


```cpp
class MinStack {
    // 记录栈中的所有元素
    stack<int> stk;
    // 阶段性记录栈中的最小元素
    stack<int> minStk;

public:
    void push(int val) {
        stk.push(val);
        // 维护 minStk 栈顶为全栈最小元素
        if (minStk.empty() || val <= minStk.top()) {
            // 新插入的这个元素就是全栈最小的
            minStk.push(val);
        }
    }

    void pop() {
        // 弹出的元素是全栈最小的
        if (stk.top() == minStk.top()) {
            minStk.pop();
        }
        stk.pop();
    }

    int top() {
        return stk.top();
    }

    int getMin() {
        // minStk 栈顶为全栈最小元素
        return minStk.top();
    }
};
```

## 单调栈

单调栈实际上就是栈，只是利用了一些巧妙的逻辑，使得每次新元素入栈后，栈内的元素都保持有序（单调递增或单调递减）。

### 使用场景

1. 下一个最大元素，包括环形数组
2. 下一个更大或相等的元素
3. 下一个更小的元素
4. 下一个更小或相等的元素
5. 上一个更大元素
6. 上一个更大或相等的元素
7. 上一个更小的元素
8. 上一个更小或相等的元素

### 模板

<span id = "下一个更大的元素"></span>

现在给你出这么一道题：输入一个数组 nums，请你返回一个等长的结果数组，结果数组中对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1。函数签名如下：

```c
int[] nextGreaterElement(int[] nums);
```

比如说，输入一个数组 nums = [2,1,2,4,3]，你返回数组 [4,2,4,-1,-1]。因为第一个 2 后面比 2 大的数是 4; 1 后面比 1 大的数是 2；第二个 2 后面比 2 大的数是 4; 4 后面没有比 4 大的数，填 -1；3 后面没有比 3 大的数，填 -1。

这道题的暴力解法很好想到，就是对每个元素后面都进行扫描，找到第一个更大的元素就行了。但是暴力解法的时间复杂度是 O(n^2)。

这个问题可以这样抽象思考：把数组的元素想象成并列站立的人，元素大小想象成人的身高。这些人面对你站成一列，如何求元素「2」的下一个更大元素呢？很简单，如果能够看到元素「2」，那么他后面可见的第一个人就是「2」的下一个更大元素，因为比「2」小的元素身高不够，都被「2」挡住了，第一个露出来的就是答案。

![image.png](https://note.youdao.com/yws/res/18530/WEBRESOURCE8aee972beb8ebe5210cb67830c5d0e9c)



```c
int[] nextGreaterElement(int[] nums) {
    int n = nums.length;
    // 存放答案的数组
    int[] res = new int[n];
    Stack<Integer> s = new Stack<>(); 
    // 倒着往栈里放
    for (int i = n - 1; i >= 0; i--) {
        // 判定个子高矮
        while (!s.isEmpty() && s.peek() <= nums[i]) {
            // 矮个起开，反正也被挡着了。。。
            s.pop();
        }
        // nums[i] 身后的更大元素
        res[i] = s.isEmpty() ? -1 : s.peek();
        s.push(nums[i]);
    }
    return res;
}
```

这就是单调队列解决问题的模板。for 循环要从后往前扫描元素，因为我们借助的是栈的结构，倒着入栈，其实是正着出栈。while 循环是把两个「个子高」元素之间的元素排除，因为他们的存在没有意义，前面挡着个「更高」的元素，所以他们不可能被作为后续进来的元素的下一个更大元素了。

这个算法的时间复杂度不是那么直观，如果你看到 for 循环嵌套 while 循环，可能认为这个算法的复杂度也是 O(n^2)，但是实际上这个算法的复杂度只有 O(n)。

分析它的时间复杂度，要从整体来看：总共有 n 个元素，每个元素都被 push 入栈了一次，而最多会被 pop 一次，没有任何冗余操作。所以总的计算规模是和元素规模 n 成正比的，也就是 O(n) 的复杂度。

### 问题变形

#### 下一个更大元素I
https://leetcode.cn/problems/next-greater-element-i/description/

![image.png](https://note.youdao.com/yws/res/18540/WEBRESOURCE669426111f7af9fc4d8940a5b1f58364)

给你输入两个数组 nums1 和 nums2，让你求 nums1 中的元素在 nums2 中的下一个更大元素，函数签名如下：

```
int[] nextGreaterElement(int[] nums1, int[] nums2)
```

因为题目说 nums1 是 nums2 的子集，那么我们先把 nums2 中每个元素的下一个更大元素算出来存到一个映射里，然后再让 nums1 中的元素去查表即可：

```c
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        // 记录 nums2 中每个元素的下一个更大元素
        vector<int> greater = nextGreaterElement(nums2);
        // 转化成映射：元素 x -> x 的下一个最大元素
        map<int, int> greaterMap;
        for (int i = 0; i < nums2.size(); i++) {
            greaterMap[nums2[i]] = greater[i];
        }
        // nums1 是 nums2 的子集，所以根据 greaterMap 可以得到结果
        vector<int> res(nums1.size());
        for (int i = 0; i < nums1.size(); i++) {
            res[i] = greaterMap[nums1[i]];
        }
        return res;
    }

    // 计算 nums 中每个元素的下一个更大元素
    vector<int> nextGreaterElement(vector<int>& nums) {
        int n = nums.size();
        // 存放答案的数组
        vector<int> res(n);
        stack<int> s;
        // 倒着往栈里放
        for (int i = n - 1; i >= 0; i--) {
            // 判定个子高矮
            while (!s.empty() && s.top() <= nums[i]) {
                // 矮个起开，反正也被挡着了。。。
                s.pop();
            }
            // nums[i] 身后的下一个更大元素
            res[i] = s.empty() ? -1 : s.top();
            s.push(nums[i]);
        }
        return res;
    }
};
```


#### 下一个更大元素II

![image.png](https://note.youdao.com/yws/res/18553/WEBRESOURCE848fd1319a3d575b8d09759190db9f0e)

- 思路

如何处理环形数组，由于环形数组只会比较该元素前面的元素一次，暴力解法就是将前面的元素截到后面，如图：
![image.png](https://note.youdao.com/yws/res/18564/WEBRESOURCE80155bf03599cd47d2e81d86e710013d)

但是该方法不好，可以考虑通过 % 运算符求模（余数），来模拟环形特效：

```c
int[] arr = {1,2,3,4,5};
int n = arr.length, index = 0;
while (true) {
    // 在环形数组中转圈
    print(arr[index % n]);
    index++;
}
```

```c
int[] nextGreaterElements(int[] nums) {
    int n = nums.length;
    int[] res = new int[n];
    Stack<Integer> s = new Stack<>();
    // 数组长度加倍模拟环形数组
    for (int i = 2 * n - 1; i >= 0; i--) {
        // 索引 i 要求模，其他的和模板一样
        while (!s.isEmpty() && s.peek() <= nums[i % n]) {
            s.pop();
        }
        res[i % n] = s.isEmpty() ? -1 : s.peek();
        s.push(nums[i % n]);
    }
    return res;
}
```

#### 每日温度

![image.png](https://note.youdao.com/yws/res/18574/WEBRESOURCE6577410181ccf720db52239fde7d1919)


思路：求的是几天后，那么栈存储天数，数组存储 对应天数 - 当前天数

```c
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int n = temperatures.size();
        vector<int>res(n);
        stack<int>stk;
        for(int i = n-1;i>=0;i--){
            while(!stk.empty() && temperatures[stk.top()]<=temperatures[i]){
                stk.pop();
            }
            res[i] = stk.empty() ? 0 : (stk.top() - i);
            stk.push(i);
        }
        return res;
    }
};
```


### 单调栈的几种变体模板

#### 下一个更大的元素

```
输入：nums = [1, 3, 2, 4, 4]
返回：res = [3, 4, 4, -1, -1]
```

```cpp
// 计算 nums 中每个元素的下一个更大元素
int[] nextGreaterElement(int[] nums) {
    int n = nums.length;
    // 存放答案的数组
    int[] res = new int[n];
    Stack<Integer> stk = new Stack<>(); 
    // 因为是求 nums[i] 后面的元素，所以倒着往栈里放
    for (int i = n - 1; i >= 0; i--) {
        // 删掉 nums[i] 后面较小的元素
        while (!stk.isEmpty() && stk.peek() <= nums[i]) {
            stk.pop();
        }
        // 现在栈顶就是 nums[i] 身后的更大元素
        res[i] = stk.isEmpty() ? -1 : stk.peek();
        stk.push(nums[i]);
    }
    return res;
}
```

如何理解？[跳转](#下一个更大的元素)

#### 下一个更大或相等的元素

让你计算 `nums[i]` 的下一个大于等于 `nums[i]` 的元素怎么算？比如下面这个例子：

```
输入：nums = [1, 3, 2, 4, 4]
返回：res = [3, 4, 4, 4, -1]
```

把上面这段代码中 `while` 循环的 `<=` 号改成 `<` 号即可：

```cpp
// 计算 nums 中每个元素的下一个更大或相等的元素
int[] nextGreaterOrEqualElement(int[] nums) {
    int n = nums.length;
    int[] res = new int[n];
    Stack<Integer> stk = new Stack<>(); 
    for (int i = n - 1; i >= 0; i--) {
        // 把这里改成 < 号
        while (!stk.isEmpty() && stk.peek() < nums[i]) {
            stk.pop();
        }
        // 现在栈顶就是 nums[i] 身后的大于等于 nums[i] 的元素
        res[i] = stk.isEmpty() ? -1 : stk.peek();
        stk.push(nums[i]);
    }
    return res;
}
```

#### 下一个更小的元素

让你计算 `nums[i]` 的下一个小于 `nums[i]` 的元素

```
输入：nums = [8, 4, 6, 6, 3]
返回：res = [4, 3, 3, 3, -1]
```

把之前实现的 `nextGreaterElement` 中 `while` 循环的 `<=` 条件改成 `>=` 条件即可得出下一个更小的元素：

```cpp
// 计算 nums 中每个元素的下一个更小的元素
int[] nextLessElement(int[] nums) {
    int n = nums.length;
    // 存放答案的数组
    int[] res = new int[n];
    Stack<Integer> stk = new Stack<>(); 
    // 倒着往栈里放
    for (int i = n - 1; i >= 0; i--) {
        // 删掉 nums[i] 后面较大的元素
        while (!stk.isEmpty() && stk.peek() >= nums[i]) {
            stk.pop();
        }
        // 现在栈顶就是 nums[i] 身后的更小元素
        res[i] = stk.isEmpty() ? -1 : stk.peek();
        stk.push(nums[i]);
    }
    return res;
}
```

#### 下一个更小或相等的元素

计算 `nums[i]` 的下一个小于或等于 `nums[i]` 的元素

```
输入：nums = [8, 4, 6, 6, 3]
返回：res = [4, 3, 6, 3, -1]
```

把 `nextLessElement` 函数的 `while` 循环中的 `>=` 改成 `>` 即可:

```cpp
// 计算 nums 中每个元素的下一个更小或相等的元素
int[] nextLessOrEqualElement(int[] nums) {
    int n = nums.length;
    // 存放答案的数组
    int[] res = new int[n];
    Stack<Integer> stk = new Stack<>();
    // 倒着往栈里放
    for (int i = n - 1; i >= 0; i--) {
        // 删掉 nums[i] 后面较大的元素
        while (!stk.isEmpty() && stk.peek() > nums[i]) {
            stk.pop();
        }
        // 现在栈顶就是 nums[i] 身后的更小或相等元素
        res[i] = stk.isEmpty() ? -1 : stk.peek();
        stk.push(nums[i]);
    }
    return res;
}
```

#### 上一个更大元素

计算 `nums[i]` 的上一个更大元素

```
输入：nums = [8, 7, 6, 7]
返回：res = [-1, 8, 7, 8]
```

注意之前我们的 `for` 循环都是从数组的尾部开始往栈里添加元素，这样栈顶元素就是 `nums[i]` 之后的元素。所以只要我们从数组的头部开始往栈里添加元素，栈顶的元素就是 `nums[i]` 之前的元素，即可计算 `nums[i]` 的上一个更大元素。

```cpp
// 计算 nums 中每个元素的上一个更大元素
int[] prevGreaterElement(int[] nums) {
    int n = nums.length;
    int[] res = new int[n];
    Stack<Integer> stk = new Stack<>(); 
    // 因为是求 nums[i] 前面的元素，所以正着往栈里放
    for (int i = 0; i < n; i++) {
        // 删掉 nums[i] 前面较小的元素
        while (!stk.isEmpty() && stk.peek() <= nums[i]) {
            stk.pop();
        }
        // 现在栈顶就是 nums[i] 前面的更大元素
        res[i] = stk.isEmpty() ? -1 : stk.peek();
        stk.push(nums[i]);
    }
    return res;
}
```

#### 上一个更大或相等的元素

```
输入：nums = [8, 7, 6, 7]
返回：res = [-1, 8, 7, 8]
```

```cpp
// 计算 nums 中每个元素的上一个更大或相等元素
int[] prevGreaterOrEqualElement(int[] nums) {
    int n = nums.length;
    int[] res = new int[n];
    Stack<Integer> stk = new Stack<>(); 
    for (int i = 0; i < n; i++) {
        // 注意不等号
        while (!stk.isEmpty() && stk.peek() < nums[i]) {
            stk.pop();
        }
        // 现在栈顶就是 nums[i] 前面的更大或相等元素
        res[i] = stk.isEmpty() ? -1 : stk.peek();
        stk.push(nums[i]);
    }
    return res;
}
```

#### 上一个更小的元素

```
输入：nums = [3, 6, 6, 5]
返回：res = [-1, 3, 3, 3]
```

```cpp
// 计算 nums 中每个元素的上一个更小的元素
int[] prevLessElement(int[] nums) {
    int n = nums.length;
    int[] res = new int[n];
    Stack<Integer> stk = new Stack<>(); 
    for (int i = 0; i < n; i++) {
        // 把 nums[i] 之前的较大元素删除
        while (!stk.isEmpty() && stk.peek() >= nums[i]) {
            stk.pop();
        }
        // 现在栈顶就是 nums[i] 前面的更小元素
        res[i] = stk.isEmpty() ? -1 : stk.peek();
        stk.push(nums[i]);
    }
    return res;
}
```


#### 上一个更小或相等的元素

<span id = "上一个更小或相等的元素"></span>

```
输入：nums = [3, 6, 6, 5]
返回：res = [-1, 3, 6, 3]
```

```cpp
// 计算 nums 中每个元素的上一个更小或相等元素
int[] prevLessOrEqualElement(int[] nums) {
    int n = nums.length;
    int[] res = new int[n];
    Stack<Integer> stk = new Stack<>(); 
    for (int i = 0; i < n; i++) {
        // 注意不等号
        while (!stk.isEmpty() && stk.peek() > nums[i]) {
            stk.pop();
        }
        // 现在栈顶就是 nums[i] 前面的更小或相等元素
        res[i] = stk.isEmpty() ? -1 : stk.peek();
        stk.push(nums[i]);
    }
    return res;
}
```

### 实例

#### 链表中的下一个更大节点

![image.png](https://note.youdao.com/yws/res/18649/WEBRESOURCE227c784f8b2d8c0c8f0dd46c7fa871d5)

思路：这道题输入的是一条单链表，我们把它转化成数组，方便用索引访问即可直接套用 单调栈模板 中的 nextGreaterElement 函数逻辑。

```cpp
class Solution {
public:
    vector<int> nextLargerNodes(ListNode* head) {
        // 把单链表转化成数组，方便通过索引访问
        vector<int> nums;
        ListNode* p = head;
        while (p) {
            nums.push_back(p->val);
            p = p->next;
        }
        // 存放答案的数组
        vector<int> res(nums.size(), 0);
        stack<int> stk;
        // 单调栈模板，求下一个更大元素，从后往前遍历
        for (int i = nums.size() - 1; i >= 0; i--) {
            while (!stk.empty() && stk.top() <= nums[i]) {
                stk.pop();
            }
            // 本题要求没有下一个更大元素时返回 0
            res[i] = stk.empty() ? 0 : stk.top();
            stk.push(nums[i]);
        }
        return res;
    }
};
```

#### 队列中可以看到的人数

![image.png](https://note.youdao.com/yws/res/18655/WEBRESOURCEb0dc3d2ba275aff0fee8c628396259b6)

思路：这道题显然要用到 单调栈技巧：靠左的高个子可以把靠右相邻的矮个子都「挤掉」，相当于计算下一个更大元素，即 单调栈的几种模板实现 中的 nextGreaterElement 函数。


```cpp
class Solution {
public:
    vector<int> canSeePersonsCount(vector<int>& heights) {
        int n = heights.size();
        vector<int> res(n);
        stack<int> stk; //记录比当前元素矮的元素
        for (int i = n - 1; i >= 0; i--) {
            // record the number of people who are shorter than themselves on the right.
            int count = 0;
            // 单调栈模板，计算下一个更大或相等元素（身高）
            while (!stk.empty() && heights[i] > stk.top()) {
                stk.pop();
                count++;
            }
            res[i] = stk.empty() ? count : count + 1; // 如果栈为空，也就是没有更高的人，那么矮于自己的人数就为count，否则再加上光能穿过更高的人
            stk.push(heights[i]);
        }
        return res;
    }
};
```

#### 股票价格跨度

![image.png](https://note.youdao.com/yws/res/19505/WEBRESOURCEeddcc1c8aeee31d2fef1e9c15abecad9)

- 思路

这道题显然要用到 单调栈技巧：当加入 price 时，把所有小于等于 price 的价格都「挤掉」，相当于计算前一个更大元素，即 单调栈的几种模板实现 中的 prevGreaterElement 函数。

比如已经入栈的价格序列是 [40, 30, 20, 10]，那么如果执行 next(25)，价格序列变成 [40, 30, 25]，20 和 10 都会被「挤掉」，算上 25 本身，函数返回 2 + 1 = 3。

但还有个问题，这个 3 应该作为「权重」和 25 一同存储在栈中。因为之后 25 还可能被挤掉，比如说执行 next(26)，价格序列就变成了 [40, 30, 26]，但这种情况下之前的 20 和 10 显然也应该被挤掉，函数应该返回 3 + 1 = 4。

- 实现：

```c
class StockSpanner {
    stack<vector<int>> stk; // 使用vector代替int[]，记录 {价格，小于等于该价格的天数} 二元组
public:
    int next(int price) {
        // 算上当天
        int count = 1;
        // 单调栈模板
        while (!stk.empty() && price >= stk.top()[0]) {
            // 挤掉价格低于 price 的记录
            auto prev = stk.top();
            stk.pop();
            // 计算小于等于 price 的天数
            count += prev[1];
        }
        stk.push({price, count});

        return count;
    }
};
```

- 分析：

> 为什么是求前一个最大值

因为要计算前面小于等于该元素的值，所以要一直找，直到找到大于该元素值时停止。此时找的元素个数，即所要求的元素个数+1

> 为什么要用`count += prev[1]`呢

因为如果前面元素b小于该元素a，那么说明前面元素b是已经去除掉小于本身元素b的元素了，所以需要用累加的方式加上

#### **移掉K位数字**（重要）

![image.png](https://note.youdao.com/yws/res/20091/WEBRESOURCE178d4c42fc22158ec2def3431d7293d1)


分析：要找到剩下数字最小，说明整个数字排列，前面单个数字小，后面单个数字大，呈现递增的形式，所以

1. 先删除 num 中的若干数字，使得 num 从左到右每一位都单调递增。比如 14329 转化成 129，这需要使用到 单调栈技巧。

2. num 中的每一位变成单调递增的之后，如果 k 还大于 0（还可以继续删除）的话，则删除尾部的数字，比如 129 删除成 12。

> 利用[上一个更小或相等的元素方法](#上一个更小或相等的元素)

```c
// 注意：cpp 代码由 chatGPT🤖 根据我的 java 代码翻译，旨在帮助不同背景的读者理解算法逻辑。
// 本代码已经通过力扣的测试用例，应该可直接成功提交。

class Solution {
public:
    string removeKdigits(string num, int k) {
        stack<char> stk;
        for (char c : num) {
            // 单调栈代码模板
            while (!stk.empty() && c < stk.top() && k > 0)   {
                stk.pop();
                k--;
            }
            // 防止 0 作为数字的开头
            if (stk.empty() && c == '0') {
                continue;
            }
            stk.push(c);
        }

        // 此时栈中元素单调递增，若 k 还没用完的话删掉栈顶元素
        while (k > 0 && !stk.empty()) {
            stk.pop();
            k--;
        }
        // 若最后没剩下数字，就是 0
        if (stk.empty()) {
            return "0";
        }
        // 将栈中字符转化成字符串
        string ans = "";
        while (!stk.empty()) {
            ans += stk.top();
            stk.pop();
        }
        // 出栈顺序和字符串顺序是反的
        reverse(ans.begin(), ans.end());
        return ans;
    }
};
```

> 如何理解呢？

首先要搞明白`stk`栈中存的是什么？此代码使用[上一个更小或相等的元素](#上一个更小或相等的元素),如果轮到该元素，则判断前面元素是否小于该元素，是则跳过，否则删除。然后将该元素入栈。

![image.png](https://note.youdao.com/yws/res/20104/WEBRESOURCE25d963af764af1218b11379f390eb7c7)

> 能否用下一个更大或相等的元素呢？

不能，因为要搞明白，下一个更大或相等的元素是从后往前进行判别的，所以当进行到`k=1`时，判别是否满足循环条件，如果满足，此时`k--`，终止循环，如果未遍历完，则会留下前面的数，而无法保证是最大。

比如 `num = 42529739`and`k = 2`，那么结果为：`425299`,如果用上一个更小或相等的元素，则为`229739` 


## 单调队列

### 使用场景

给你一个数组 window，已知其最值为 A，如果给 window 中添加一个数 B，那么比较一下 A 和 B 就可以立即算出新的最值；但如果要从 window 数组中减少一个数，就不能直接得到最值了，因为如果减少的这个数恰好是 A，就需要遍历 window 中的所有元素重新寻找新的最值。

「单调队列」这个数据结构主要用来辅助解决滑动窗口相关的问题

> 一些问题

单纯地维护最值的话，优先级队列很专业，队头元素就是最值。但优先级队列无法满足标准队列结构「先进先出」的时间顺序，因为优先级队列底层利用二叉堆对元素进行动态排序，元素的出队顺序是元素的大小顺序，和入队的先后顺序完全没有关系。

**既能够维护队列元素「先进先出」的时间顺序，又能够正确维护队列中所有元素的最值，这就是「单调队列」结构**

### 框架

普通的队列的标准 API：

```c
class Queue {
    // enqueue 操作，在队尾加入元素 n
    void push(int n);
    // dequeue 操作，删除队头元素
    void pop();
}
```

要实现的「单调队列」的 API :

```c
class MonotonicQueue {
    // 在队尾添加元素 n
    void push(int n);
    // 返回当前队列中的最大值
    int max();
    // 队头元素如果是 n，删除它
    void pop(int n);
}
```

- 实现：

```c
  /* 单调队列的实现 */
    class MonotonicQueue {
    private:
        deque<int> q;
    public:
        void push(int n) {
            // 将小于 n 的元素全部删除
            while (!q.empty() && q.back() < n) {
                q.pop_back();
            }
            // 然后将 n 加入尾部
            q.push_back(n);
        }

        int max() {
            return q.front();
        }

        void pop(int n) {
            if (n == q.front()) {
                q.pop_front();
            }
        }
    };

```

1. `push()`操作

可以想象，加入数字的大小代表人的体重，把前面体重不足的都压扁了，直到遇到更大的量级才停住。

![](https://labuladong.github.io/algo/images/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/3.png)

2. `pop()`操作

之所以要判断 `data.getFirst() == n`，是因为我们想删除的队头元素 n 可能已经被「压扁」了，可能已经不存在了，所以这时候就不用删除了：

![](https://labuladong.github.io/algo/images/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/2.png)


- 完整实现：

```c
/* 单调队列的实现，可以高效维护最大值和最小值 */
template<typename E>
class MonotonicQueue {
    // 常规队列，存储所有元素
    std::deque<E> q;
    // 元素降序排列的单调队列，头部是最大值
    std::deque<E> maxq;
    // 元素升序排列的单调队列，头部是最小值
    std::deque<E> minq;

public:
    void push(E elem) {
        // 维护常规队列，直接在队尾插入元素
        q.push_back(elem);

        // 维护 maxq，将小于 elem 的元素全部删除
        while (!maxq.empty() && maxq.back() < elem) {
            maxq.pop_back();
        }
        maxq.push_back(elem);

        // 维护 minq，将大于 elem 的元素全部删除
        while (!minq.empty() && minq.back() > elem) {
            minq.pop_back();
        }
        minq.push_back(elem);
    }

    E max() {
        // maxq 的头部是最大元素
        return maxq.front();
    }

    E min() {
        // minq 的头部是最小元素
        return minq.front();
    }

    E pop() {
        // 从标准队列头部弹出需要删除的元素
        E deleteVal = q.front();
        q.pop_front();

        // 由于 push 的时候会删除元素，deleteVal 可能已经被删掉了
        if (deleteVal == maxq.front()) {
            maxq.pop_front();
        }
        if (deleteVal == minq.front()) {
            minq.pop_front();
        }
        return deleteVal;
    }

    int size() {
        // 标准队列的大小即是当前队列的大小
        return q.size();
    }

    bool isEmpty() {
        return q.empty();
    }
};
```

### 实例

#### 滑动窗口最大值

![image.png](https://note.youdao.com/yws/res/20766/WEBRESOURCE5c615ac023a1a20fc953df6bea9d3138)


利用单调队列实现

```c
class Solution {
public:
    /* 单调队列的实现 */
    class MonotonicQueue {
    private:
        deque<int> q;
    public:
        void push(int n) {
            // 将小于 n 的元素全部删除
            while (!q.empty() && q.back() < n) {
                q.pop_back();
            }
            // 然后将 n 加入尾部
            q.push_back(n);
        }

        int max() {
            return q.front();
        }

        void pop(int n) {
            if (n == q.front()) {
                q.pop_front();
            }
        }
    };

    /* 解题函数的实现 */
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        MonotonicQueue window;
        vector<int> res;

        for (int i = 0; i < nums.size(); i++) {
            if (i < k - 1) {
                //先填满窗口的前 k - 1
                window.push(nums[i]);
            } else {
                // 窗口向前滑动，加入新数字
                window.push(nums[i]);
                // 记录当前窗口的最大值
                res.push_back(window.max());
                // 移出旧数字
                window.pop(nums[i - k + 1]);
            }
        }

        return res;
    }
};
```

#### 队列的最大值

![image.png](https://note.youdao.com/yws/res/20777/WEBRESOURCEddc18fb137ee141cea4fd5675fb4ea8a)

```c
class MaxQueue {
private:
    deque<int> dq;
    queue<int> temp;
public:
    MaxQueue() {

    }
    
    int max_value() {
        if(dq.empty()) return -1;
        return dq.front();
    }
    
    void push_back(int value) {
        while(!dq.empty() && dq.back() < value){
            dq.pop_back();
        }
        dq.push_back(value);
        temp.push(value);
    }
    
    int pop_front() {
        if(temp.empty()) return -1;
        int fn = temp.front();
        if(fn == dq.front()) {
            dq.pop_front();
        }
        temp.pop();
        return fn;
    }
};
```


#### 和至少为 K 的最短子数组

![image.png](https://note.youdao.com/yws/res/21069/WEBRESOURCEf3d74679e86935fa1f4e126ac67f1ffe)

> 分析

这题的难度是比较大的，难点在于同时结合了 滑动窗口算法、前缀和技巧 和 单调队列 几个知识点。

首先，想要快速记录子数组的和，需要 前缀和技巧 预计算一个 `preSum` 数组，然后在这个 `preSum` 数组上施展 滑动窗口算法 寻找一个差值大于 k 且宽度最小的「窗口」，这个窗口的大小就是题目想要的结果。

这里面还有个问题，当滑动窗口扩大时，新进入窗口的元素 `preSum[right]` 需要知道窗口中最小的那个元素是多少，和最小的那个元素相减才能得到尽可能大的子数组和。

如何快速判断窗口中的最值？这就需要单调队列结构

```c
/* 单调队列的实现，可以高效维护最大值和最小值 */
template<typename E>
class MonotonicQueue {
    // 常规队列，存储所有元素
    std::deque<E> q;
    // 元素降序排列的单调队列，头部是最大值
    std::deque<E> maxq;
    // 元素升序排列的单调队列，头部是最小值
    std::deque<E> minq;

public:
    void push(E elem) {
        // 维护常规队列，直接在队尾插入元素
        q.push_back(elem);

        // 维护 maxq，将小于 elem 的元素全部删除
        while (!maxq.empty() && maxq.back() < elem) {
            maxq.pop_back();
        }
        maxq.push_back(elem);

        // 维护 minq，将大于 elem 的元素全部删除
        while (!minq.empty() && minq.back() > elem) {
            minq.pop_back();
        }
        minq.push_back(elem);
    }

    E max() {
        // maxq 的头部是最大元素
        return maxq.front();
    }

    E min() {
        // minq 的头部是最小元素
        return minq.front();
    }

    E pop() {
        // 从标准队列头部弹出需要删除的元素
        E deleteVal = q.front();
        q.pop_front();

        // 由于 push 的时候会删除元素，deleteVal 可能已经被删掉了
        if (deleteVal == maxq.front()) {
            maxq.pop_front();
        }
        if (deleteVal == minq.front()) {
            minq.pop_front();
        }
        return deleteVal;
    }

    int size() {
        // 标准队列的大小即是当前队列的大小
        return q.size();
    }

    bool isEmpty() {
        return q.empty();
    }
};

class Solution {
   public:
    int shortestSubarray(vector<int>& nums, int k) {
        int n = nums.size();
        // 看题目的数据范围，前缀和数组中元素可能非常大，所以用 long 类型
        vector<long> preSum(n + 1, 0);
        // 计算 nums 的前缀和数组
        for (int i = 1; i <= n; i++) {
            preSum[i] = preSum[i - 1] + nums[i - 1];
        }
        // 单调队列结构辅助滑动窗口算法
        MonotonicQueue<long> window;
        int right = 0, left = 0;
        int len = INT_MAX;
        // 开始执行滑动窗口算法框架
        while (right < preSum.size()) {
            // 扩大窗口，元素入队
            window.push(preSum[right]);
            right++;
            // 若新进入窗口的元素和窗口中的最小值之差大于等于 k，
            // 说明得到了符合条件的子数组，缩小窗口，使子数组长度尽可能小
            while (right < preSum.size() && !window.isEmpty() &&
                   preSum[right] - window.min() >= k) {
                // 更新答案
                len = min(len, right - left);
                // 缩小窗口
                window.pop();
                left++;
            }
        }
        return len == INT_MAX ? -1 : len;
    }
};
```


> 需要注意的地方

1. 为什么用前缀和？

因为题目要求子数组的和，满足前缀和情况

2. 为什么要用单调队列？为什么要和最小值比较呢？不能直接用滑动窗口吗

因为要考虑到有负数的情况。如果窗口增大，加入一个负数，总和反而减小，所以用单调队列，将最小值表示出来，如果该最小值符合条件，则缩小窗口。如果加入的值是负数，最小值不变，相当于常规队列增加该元素，单调队列不变。

4. 如何理解缩小窗口这部分的代码

当满足条件，更新答案，缩小窗口。如果最小值改变，说明加入的是整数，如果最小值不变，说明加入的是负数，此时只是去除了常规队列的元素。


#### 绝对差不超过限制的最长连续子数组

当窗口内绝对值之差不超过 limit 时扩大窗口，当新加入窗口的元素使得绝对值之差超过 limit 时开始收缩窗口，窗口的最大宽度即最长子数组的长度。

但有个问题，当窗口进新元素时，我可以更新窗口中的最大值和最小值，但当窗口收缩时，如何更新最大值和最小值呢？难道要遍历一遍窗口中的所有元素吗？这就用到单调队列结构了，这里需要一个通用的 MonotonicQueue 类，用来高效判断窗口中的最大值和最小值。


```c
template<typename E>
class MonotonicQueue {
    // 常规队列，存储所有元素
    std::deque<E> q;
    // 元素降序排列的单调队列，头部是最大值
    std::deque<E> maxq;
    // 元素升序排列的单调队列，头部是最小值
    std::deque<E> minq;

public:
    void push(E elem) {
        // 维护常规队列，直接在队尾插入元素
        q.push_back(elem);

        // 维护 maxq，将小于 elem 的元素全部删除
        while (!maxq.empty() && maxq.back() < elem) {
            maxq.pop_back();
        }
        maxq.push_back(elem);

        // 维护 minq，将大于 elem 的元素全部删除
        while (!minq.empty() && minq.back() > elem) {
            minq.pop_back();
        }
        minq.push_back(elem);
    }

    E max() {
        // maxq 的头部是最大元素
        return maxq.front();
    }

    E min() {
        // minq 的头部是最小元素
        return minq.front();
    }

    E pop() {
        // 从标准队列头部弹出需要删除的元素
        E deleteVal = q.front();
        q.pop_front();

        // 由于 push 的时候会删除元素，deleteVal 可能已经被删掉了
        if (deleteVal == maxq.front()) {
            maxq.pop_front();
        }
        if (deleteVal == minq.front()) {
            minq.pop_front();
        }
        return deleteVal;
    }

    int size() {
        // 标准队列的大小即是当前队列的大小
        return q.size();
    }

    bool isEmpty() {
        return q.empty();
    }
};

class Solution {
public:
    int longestSubarray(vector<int>& nums, int limit) {
        MonotonicQueue<int>q;
        int left=0;int right=0;
        int res = 0;
        while(right <nums.size()){
            q.push(nums[right]);
            right++;
            while(q.max() - q.min() > limit){
                q.pop();
                left++;
            }
            res = max(res,right -left);
        }
        return res;
    }
};
```

> 分析

用单调队列求出最大最小值，两个值的差要小于`limit`，用滑动窗口约束。


#### 918. 环形子数组的最大和

![image.png](https://note.youdao.com/yws/res/21070/WEBRESOURCEfaacb36c00ad50d84c7d83329b6a34b8)

首先，处理环形数组的方法，其实就是把原数组大小扩大一倍，这样就能模拟出环形的效果了。

那么本题也可以把 nums 数组扩大一倍，计算前缀和数组 preSum，借助一个定长为 nums.length 的单调队列来计算环形数组中的最大子数组和。


```c
template<typename E>
class MonotonicQueue {
    // 常规队列，存储所有元素
    std::deque<E> q;
    // 元素降序排列的单调队列，头部是最大值
    std::deque<E> maxq;
    // 元素升序排列的单调队列，头部是最小值
    std::deque<E> minq;

public:
    void push(E elem) {
        // 维护常规队列，直接在队尾插入元素
        q.push_back(elem);

        // 维护 maxq，将小于 elem 的元素全部删除
        while (!maxq.empty() && maxq.back() < elem) {
            maxq.pop_back();
        }
        maxq.push_back(elem);

        // 维护 minq，将大于 elem 的元素全部删除
        while (!minq.empty() && minq.back() > elem) {
            minq.pop_back();
        }
        minq.push_back(elem);
    }

    E max() {
        // maxq 的头部是最大元素
        return maxq.front();
    }

    E min() {
        // minq 的头部是最小元素
        return minq.front();
    }

    E pop() {
        // 从标准队列头部弹出需要删除的元素
        E deleteVal = q.front();
        q.pop_front();

        // 由于 push 的时候会删除元素，deleteVal 可能已经被删掉了
        if (deleteVal == maxq.front()) {
            maxq.pop_front();
        }
        if (deleteVal == minq.front()) {
            minq.pop_front();
        }
        return deleteVal;
    }

    int size() {
        // 标准队列的大小即是当前队列的大小
        return q.size();
    }

    bool isEmpty() {
        return q.empty();
    }
};

class Solution {
public:
    int maxSubarraySumCircular(vector<int>& nums) {
        //环形数组，从 0 - 2n-1, i%n
        int n=nums.size();
        vector<int>presum(2*n,0);
        for(int i=1;i<presum.size();i++){
            presum[i] = presum[i-1] + nums[(i-1)%n];
        }
        int maxSum = INT_MIN;
        MonotonicQueue<int> window;
        window.push(0);
        for(int i=1;i<presum.size();i++){
            maxSum = max(maxSum,presum[i] - window.min());
            if(window.size() == n) window.pop();
            window.push(presum[i]);
        }
        return maxSum;
    }
};
```

> 分析：为什么是`presum[i]-window.min()`呢

因为我们要求子数组的最大值，而不需要求长度，所以找到该数组前面元素的最小值，和当前数组做差值，即可求出子数组的最大值。

> 分析：为什么维护长度为`n`的窗口呢

因为如果不是环形的，我们如何求？直接从`0`位置以此往后扩大，利用该元素的前缀和和前面前缀和的最小值作差，不就可以得到最大值吗,但是此时是环形数组，子数组不能包含相同索引两次，所以才维护长度`n`的窗口。


# 哈希表

哈希表利用`unordered_map`

#### 字母异位词分组

![image.png](https://note.youdao.com/yws/res/21071/WEBRESOURCE9ad7d724e25db4af98cc033c2e738865)

首先考虑如何判断两个元素是否构成字母异位词？

> 方法1

```c
bool Unicode(string& s,string& t) {
    char compare[26]{0};
    for(auto c:s){
        compare[c]++;
    }
    for(auto c:t){
        compare[c]--;
    }
    for(auto c:compare){
        if(c!=0)return false;
        return true;
    }
}

```

> 方法2

```c
bool Unicode(string& s,string& t) {
    unorder_map<char,int> um;
    for(auto c:s){
        um[c] ++;
    }
    for(auto c:t){
        um[c]--;
    }
      for(auto c:um){
        if(c.second !=0)return false;
        return true;
    }
}
```

此题目能否用2次方法2？不能，不能将`unorder_map`类型作为`unorder_map`的类型

所以考虑用方法1和方法2的叠加，将方法1中的字符串作为方法2的`key`值

```c
class Solution {
public:
string Unicode(string& s) {
    char count[26]{ 0 };
    for (auto c : s) {
        int num = c - 'a';
        count[num]++;
    }
    return string(count, count + 26);
}  

vector<vector<string>> groupAnagrams(vector<string>& strs) {
    unordered_map<string, vector<string>> um;
    for (auto c : strs) {
        string temp = Unicode(c);
        um[temp].push_back(c);
    }

    vector<vector<string> >res;
    for (auto c : um) {
        res.push_back(c.second);
    }
    return res;
}
};
```

#### 多数元素


![image.png](https://note.youdao.com/yws/res/21072/WEBRESOURCE16c6126145fec0e875fe6681a39910c8)


这道题的标准解法肯定是用一个哈希表作为计数器记录每个元素出现的次数，然后寻找出现次数最多的那个元素，时间和空间复杂度都是 O(N)。

但是由于题目说了这个目标元素（众数）出现的次数过半，比方说一群带正电的粒子和一群带负电的粒子，把它们混合起来，得到的这群混合粒子的带电性质是什么？这取决于正电离子多还是负电离子多，如果正负粒子数量恰好相等，则呈电中性。

回到这道题，题目告诉你一定存在一个众数，它出现的次数过半，那么如果你把这个众数元素想象成正电粒子，其他的所有元素都想象成负电粒子，那么它们混合起来会怎样？

在正负粒子混合的过程中，整体的带电性可能在正负间波动，但最终的结果一定是正电。

用 O(1) 的空间复杂度来计算众数:

```c
class Solution {
    public int majorityElement(int[] nums) {
        // 我们想寻找的那个众数
        int target = 0;
        // 计数器（类比带电粒子例子中的带电性）
        int count = 0;
        for (int i = 0; i < nums.length; i++) {
            if (count == 0) {
                // 当计数器为 0 时，假设 nums[i] 就是众数
                target = nums[i];
                // 众数出现了一次
                count = 1;
            } else if (nums[i] == target) {
                // 如果遇到的是目标众数，计数器累加
                count++;
            } else {
                // 如果遇到的不是目标众数，计数器递减
                count--;
            }
        }
        // 回想带电粒子的例子
        // 此时的 count 必然大于 0，此时的 target 必然就是目标众数
        return target;
    }
}
```

#### **复制带随机指针的链表**（深拷贝链表）

![image.png](https://note.youdao.com/yws/res/21436/WEBRESOURCE41ede817f65e61ed1cb435e126880005)

深拷贝， 分为两步：1.拷贝节点  2.连接节点

```c
class Solution {
public:
    Node* copyRandomList(Node* head) {
        unordered_map<Node*, Node*> originToClone;
        // 第一次遍历，先把所有节点克隆出来
        for (Node* p = head; p != nullptr; p = p->next) {
            if (originToClone.count(p) == 0) {
                originToClone[p] = new Node(p->val);
            }
        }
        // 第二次遍历，把克隆节点的结构连接好
        for (Node* p = head; p != nullptr; p = p->next) {
            if (p->next != nullptr) {
                originToClone[p]->next = originToClone[p->next];
            }
            if (p->random != nullptr) {
                originToClone[p]->random = originToClone[p->random];
            }
        }
        // 返回克隆之后的头结点
        return originToClone[head];
    }
};
```

# `KPM`算法

## 使用场景

1. 匹配问题
2. 重复子串问题

## 大致框架

首先先清楚几个概念。

> 1.KMP的主要思想

当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。

> 2.什么是前缀什么是后缀

前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串。
后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。

最长相同前后缀长度：比如：`aaba`为1，`aabcaa`为2,`aabbaa`为2，`aabaab`为3

> 3.前缀表

用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。即记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。

> 4.前缀表计算

把求得的最长相同前后缀的长度就是对应前缀表的元素

![](https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B28.png)

> 5.`next`数组

next数组既可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）。

- 构造next数组其实就是计算模式串s，前缀表的过程。 

### 构造`next`数组

1. 遍历模式串

```
for(int i=1;i<s.size();i++){
    ...
}
```

2. 初始化

```c
int j=0;
next[0]=j;
```

3. 判断元素是否相同

> 处理前后缀不相同的情况

```c
while(j>0 && s[i] != s[j]){
    j = next[j-1];
}
```

> 处理前后缀相同的情况

```c
if(s[i] == s[j]){
    j++;
}

next[i] = j;
```

### 文本串匹配模式串

1. 遍历文本串

```c
for(int i=0;i<s.size();i++){
    ...
}
```

2. 判断元素是否相同

> 不相同从`next`数组找下一个匹配位置

```c
while(j>0 && s[i] != t[j]){
    j = next[j-1];
}
```

> 相同则往后移动

```c
if(s[i] == t[j]){
    j++;
}
```

3.判断满足条件情况

```c
if(j == t.size()){
    return (j - needle.size() +1);
}
```

> 注意：

1. 求`next`数组和匹配时，循环范围不同，一个从1开始，一个从0开始
2. 求`next`数组和匹配时，元素相同的步骤不同，一个需要赋值，一个不需要赋值
3. 求`next`数组和匹配时，判断结果不同，一个不需要判断，一个需要判断何时满足

- 完整代码：

```c
class Solution {
public:
    void getNext(int* next, const string& s) {
        int j = 0;
        next[0] = 0;
        for(int i = 1; i < s.size(); i++) {
            while (j > 0 && s[i] != s[j]) {
                j = next[j - 1];
            }
            if (s[i] == s[j]) {
                j++;
            }
            next[i] = j;
        }
    }
    int strStr(string haystack, string needle) {
        if (needle.size() == 0) {
            return 0;
        }
        int next[needle.size()];
        getNext(next, needle);
        int j = 0;
        for (int i = 0; i < haystack.size(); i++) {
            while(j > 0 && haystack[i] != needle[j]) {
                j = next[j - 1];
            }
            if (haystack[i] == needle[j]) {
                j++;
            }
            if (j == needle.size() ) {
                return (i - needle.size() + 1);
            }
        }
        return -1;
    }
};
```

### 重复子串

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20220728205249.png)

> key

在由重复子串组成的字符串中，**最长相等前后缀不包含的子串就是最小重复子串**

> 为什么？

比如上述例子，`01 == 23`,`23 == 45`,`45 == 67`...所以满足重复子串

1. 求出`next`数组

2. 判断是否有重复出现的子字符串

`nx % (n - m)x == 0`：则存在重复出现的子字符串，即`s.size()/(s.size()-next[s.size()-1])`


# Rabin-Karp 算法

## 使用场景

字符串匹配问题

## 大致框架

- 给你输入一个字符串形式的正整数，如何把它转化成数字的形式？

```c
string s = "8264";
int number = 0;
for (int i = 0; i < s.size(); i++) {
    // 将字符转化成数字
    number = 10 * number + (s[i] - '0');
    print(number);
}
// 打印输出：
// 8
// 82
// 826
// 8264
```

算法的核心思路就是不断向最低位（个位）添加数字，同时把前面的数字整体左移一位（乘以 10）,和我们操作二进制数的时候是一个道理，左移一位就是把二进制数乘以 2，右移一位就是除以 2。


- 如何在数字的最低位添加数字以及如何删除数字的最高位，用 `R` 表示数字的进制数，用 `L` 表示数字的位数，就可以总结出如下公式:

```c
/* 在最低位添加一个数字 */
int number = 8264;
// number 的进制
int R = 10;
// 想在 number 的最低位添加的数字
int appendVal = 3;
// 运算，在最低位添加一位
number = R * number + appendVal;
// 此时 number = 82643

/* 在最高位删除一个数字 */
int number = 8264;
// number 的进制
int R = 10;
// number 最高位的数字
int removeVal = 8;
// 此时 number 的位数
int L = 4;
// 运算，删除最高位数字
number = number - removeVal * R^(L-1);
// 此时 number = 264
```

见以下实例：重复的DNA序列

我们不要每次都去一个字符一个字符地比较子串和模式串，而是维护一个滑动窗口，运用滑动哈希算法一边滑动一边计算窗口中字符串的哈希值，拿这个哈希值去和模式串的哈希值比较，这样就可以避免截取子串，从而把匹配算法降低为 O(N)，这就是 **`Rabin-Karp` 指纹字符串查找算法的核心逻辑**

```c
#include <string>
#include <cmath>

using namespace std;

int numDistinct(string s, string t) {
    // 文本串
    string txt = s;
    // 模式串
    string pat = t;

    // 需要寻找的子串长度为模式串 pat 的长度
    int L = pat.length();
    // 仅处理 ASCII 码字符串，可以理解为 256 进制的数字
    int R = 256;
    // 存储 R^(L - 1) 的结果
    int RL = pow(R, L - 1);
    // 维护滑动窗口中字符串的哈希值
    int windowHash = 0;
    // 计算模式串的哈希值
    long long patHash = 0;
    for (int i = 0; i < pat.length(); i++) {
        patHash = R * patHash + pat[i];
    }

    // 滑动窗口代码框架
    int left = 0, right = 0;
    while (right < txt.length()) {
        // 扩大窗口，移入字符（在最低位添加数字）
        windowHash = R * windowHash + txt[right];
        right++;

        // 当子串的长度达到要求
        if (right - left == L) {
            // 根据哈希值判断窗口中的子串是否匹配模式串 pat
            if (patHash == windowHash) {
                // 找到模式串
                printf("找到模式串，起始索引为 %d", left);
                return left;
            }

            // 缩小窗口，移出字符（删除最高位数字）
            windowHash = windowHash - txt[left] * RL;
            left++;
        }
    }
    // 没有找到模式串
    return -1;
}
```

不过呢，这段代码实际运行的时候会有一个严重的问题，那就是整型溢出。如何把一个很大的数字映射到一个较小的范围内呢？答案是求模（余数）

无论一个数字多大，你让它除以 Q，余数一定会落在 [0, Q-1] 的范围内。所以我们可以设置一个 Q，用求模的方式让 `windowHash` 和 `patHash` 保持在 `[0, Q-1]` 之间，就可以有效避免整型溢出。

整型溢出的问题倒是解决了，但新的问题又来了：求模之后的哈希值不能和原始字符串一一对应了，可能出现一对多的情况，即哈希冲突。比方说 `10 % 7` 等于 3，而 `17 % 7` 也等于 3，所以如果你得到余数 3，你能确定原始数字就一定是 10 么？不能。

对于` Rabin-Karp` 算法来说，当发现 `windowHash == patHash` 时，使用暴力匹配算法检查一下窗口中的字符串和 `pat` 是否相同就可以避免哈希冲突了。因为希冲突出现的概率比较小，所以偶尔用一下暴力匹配算法是不影响总体的时间复杂度的

```c
// Rabin-Karp 指纹字符串查找算法
int rabinKarp(string txt, string pat) {
    // 位数
    int L = pat.length();
    // 进制（只考虑 ASCII 编码）
    int R = 256;
    // 取一个比较大的素数作为求模的除数
    long Q = INT_MAX;
    // R^(L - 1) 的结果
    long RL = 1;
    for (int i = 1; i <= L - 1; i++) {
        // 计算过程中不断求模，避免溢出
        RL = (RL * R) % Q;
    }
    // 计算模式串的哈希值，时间 O(L)
    long patHash = 0;
    for (int i = 0; i < pat.length(); i++) {
        patHash = (R * patHash % Q + pat[i]) % Q;
    }

    // 滑动窗口中子字符串的哈希值
    long windowHash = 0;

    // 滑动窗口代码框架，时间 O(N)
    int left = 0, right = 0;
    while (right < txt.length()) {
        // 扩大窗口，移入字符
        windowHash = ((R * windowHash) % Q + txt[right]) % Q;
        right++;

        // 当子串的长度达到要求
        if (right - left == L) {
            // 根据哈希值判断是否匹配模式串
            if (windowHash == patHash) {
                // 当前窗口中的子串哈希值等于模式串的哈希值
                // 还需进一步确认窗口子串是否真的和模式串相同，避免哈希冲突
                if (pat.compare(txt.substr(left, L)) == 0) {
                    return left;
                }
            }
            // 缩小窗口，移出字符
            windowHash = (windowHash - (txt[left] * RL) % Q + Q) % Q;
            // X % Q == (X + Q) % Q 是一个模运算法则
            // 因为 windowHash - (txt[left] * RL) % Q 可能是负数
            // 所以额外再加一个 Q，保证 windowHash 不会是负数

            left++;
        }
    }
    // 没有找到模式串
    return -1;
}
```
### 实例

#### 重复的DNA序列

![image.png](https://note.youdao.com/yws/res/22424/WEBRESOURCE00f4f8db5ecfbd2f6b871fadc2c0c568)

```c
vector<string> findRepeatedDnaSequences(string s) {
    // 先把字符串转化成四进制的数字数组
    vector<int> nums(s.length());
    for (int i = 0; i < nums.size(); i++) {
        switch (s[i]) {
            case 'A':
                nums[i] = 0;
                break;
            case 'G':
                nums[i] = 1;
                break;
            case 'C':
                nums[i] = 2;
                break;
            case 'T':
                nums[i] = 3;
                break;
        }
    }
    // 记录重复出现的哈希值
    unordered_set<int> seen;
    // 记录重复出现的字符串结果
    unordered_set<string> res;

    // 数字位数
    int L = 10;
    // 进制
    int R = 4;
    // 存储 R^(L - 1) 的结果
    int RL = pow(R, L - 1);
    // 维护滑动窗口中字符串的哈希值
    int windowHash = 0;

    // 滑动窗口代码框架，时间 O(N)
    int left = 0, right = 0;
    while (right < nums.size()) {
        // 扩大窗口，移入字符，并维护窗口哈希值（在最低位添加数字）
        windowHash = R * windowHash + nums[right];
        right++;

        // 当子串的长度达到要求
        if (right - left == L) {
            // 根据哈希值判断是否曾经出现过相同的子串
            if (seen.count(windowHash)) {
                // 当前窗口中的子串是重复出现的
                res.insert(s.substr(left, right - left));
            } else {
                // 当前窗口中的子串之前没有出现过，记下来
                seen.insert(windowHash);
            }
            // 缩小窗口，移出字符，并维护窗口哈希值（删除最高位数字）
            windowHash = windowHash - nums[left] * RL;
            left++;
        }
    }
    // 转化成题目要求的 vector 类型
    return vector<string>(res.begin(), res.end());
}

```

分析：

由于将字符转化成字符串，就难免需要 O(L) 的时间来操作，不要真的把子字符串生成出来，而是用一些其他形式的唯一标识来表示滑动窗口中的子字符串，并且还能在窗口滑动的过程中快速更新

把一个字符串对象转化成了一个数字，生成的数字就可以认为是字符串的哈希值。在滑动窗口中快速计算窗口中元素的哈希值，叫做滑动哈希技巧。






    